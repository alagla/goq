module: 'Examples.yml'
# import Qupla
# import Qupla
# import Qupla
# import Qupla

types: 
  # type Trit [1]
  Trit:
    vector: 1
    size: '1'
  # type Tryte [3]
  Tryte:
    vector: 3
    size: '3'
  # type Tiny [9]
  Tiny:
    vector: 9
    size: '9'
  # type Int [27]
  Int:
    vector: 27
    size: '27'
  # type Huge [81]
  Huge:
    vector: 81
    size: '81'
  # type Hash [243]
  Hash:
    vector: 243
    size: '243'
  # type Hash3 [729]
  Hash3:
    vector: 729
    size: '729'
  # type Hash9 [2187]
  Hash9:
    vector: 2187
    size: '2187'
  # type Signature [6561]
  Signature:
    vector: 6561
    size: '6561'
  # type Trit2 [2]
  Trit2:
    vector: 2
    size: '2'
  # type Trit4 [4]
  Trit4:
    vector: 4
    size: '4'
  # type Tryte2 [6]
  Tryte2:
    vector: 6
    size: '6'
  # type Tryte4 [12]
  Tryte4:
    vector: 12
    size: '12'
  # type Tiny2 [18]
  Tiny2:
    vector: 18
    size: '18'
  # type Tiny4 [36]
  Tiny4:
    vector: 36
    size: '36'
  # type Int2 [54]
  Int2:
    vector: 54
    size: '54'
  # type Int4 [108]
  Int4:
    vector: 108
    size: '108'
  # type Huge2 [162]
  Huge2:
    vector: 162
    size: '162'
  # type Huge4 [324]
  Huge4:
    vector: 324
    size: '324'
  # type Hash2 [486]
  Hash2:
    vector: 486
    size: '486'
  # type Hash4 [972]
  Hash4:
    vector: 972
    size: '972'
  # type Bool [Trit]
  Bool:
    vector: Trit
    size: '1'
  # type Carry [Trit]
  Carry:
    vector: Trit
    size: '1'
  # type TritCarry { ... }
  TritCarry:
    size: '*'
    fields: 
        value: 
          vector: Trit
          size: '1'
        carry: 
          vector: Carry
          size: '1'
  # type TinyFloat { ... }
  TinyFloat:
    size: '*'
    fields: 
        mantissa: 
          vector: Tiny
          size: '9'
        exponent: 
          vector: Tryte
          size: '3'
  # type Float { ... }
  Float:
    size: '*'
    fields: 
        mantissa: 
          vector: Tiny2
          size: '18'
        exponent: 
          vector: Tryte2
          size: '6'
  # type Double { ... }
  Double:
    size: '*'
    fields: 
        mantissa: 
          vector: Tiny4
          size: '36'
        exponent: 
          vector: Tiny
          size: '9'
  # type HugeFloat { ... }
  HugeFloat:
    size: '*'
    fields: 
        mantissa: 
          vector: Int2
          size: '54'
        exponent: 
          vector: Tiny2
          size: '18'
  # type Attachment { ... }
  Attachment:
    size: '*'
    fields: 
        timestamp: 
          vector: Int
          size: '27'
        timestampLowerBound: 
          vector: Int
          size: '27'
        timestampUpperBound: 
          vector: Int
          size: '27'
  # type Transaction { ... }
  Transaction:
    size: '*'
    fields: 
        signature: 
          vector: Signature
          size: '6561'
        extraDataDigest: 
          vector: Hash
          size: '243'
        address: 
          vector: Hash
          size: '243'
        value: 
          vector: Huge
          size: '81'
        issuanceTimestamp: 
          vector: Int
          size: '27'
        timelockLowerBound: 
          vector: Int
          size: '27'
        timelockUpperBound: 
          vector: Int
          size: '27'
        bundle: 
          vector: Huge
          size: '81'
        trunk: 
          vector: Hash
          size: '243'
        branch: 
          vector: Hash
          size: '243'
        tag: 
          vector: Huge
          size: '81'
        attachment: 
          vector: Attachment
          size: '81'
        nonce: 
          vector: Huge
          size: '81'
luts: 
  # lut not
  not:
    lutTable:
      - '0 = 1'
      - '1 = 0'
  # lut and
  and:
    lutTable:
      - '00 = 0'
      - '01 = 0'
      - '10 = 0'
      - '11 = 1'
  # lut and3
  and3:
    lutTable:
      - '000 = 0'
      - '001 = 0'
      - '010 = 0'
      - '011 = 0'
      - '100 = 0'
      - '101 = 0'
      - '110 = 0'
      - '111 = 1'
  # lut or
  or:
    lutTable:
      - '00 = 0'
      - '01 = 1'
      - '10 = 1'
      - '11 = 1'
  # lut or3
  or3:
    lutTable:
      - '000 = 0'
      - '001 = 1'
      - '010 = 1'
      - '011 = 1'
      - '100 = 1'
      - '101 = 1'
      - '110 = 1'
      - '111 = 1'
  # lut xor
  xor:
    lutTable:
      - '00 = 0'
      - '01 = 1'
      - '10 = 1'
      - '11 = 0'
  # lut xor3
  xor3:
    lutTable:
      - '000 = 0'
      - '001 = 1'
      - '010 = 1'
      - '011 = 0'
      - '100 = 1'
      - '101 = 0'
      - '110 = 0'
      - '111 = 1'
  # lut nand
  nand:
    lutTable:
      - '00 = 1'
      - '01 = 1'
      - '10 = 1'
      - '11 = 0'
  # lut nand3
  nand3:
    lutTable:
      - '000 = 1'
      - '001 = 1'
      - '010 = 1'
      - '011 = 1'
      - '100 = 1'
      - '101 = 1'
      - '110 = 1'
      - '111 = 0'
  # lut nor
  nor:
    lutTable:
      - '00 = 1'
      - '01 = 0'
      - '10 = 0'
      - '11 = 0'
  # lut nor3
  nor3:
    lutTable:
      - '000 = 1'
      - '001 = 0'
      - '010 = 0'
      - '011 = 0'
      - '100 = 0'
      - '101 = 0'
      - '110 = 0'
      - '111 = 0'
  # lut xnor
  xnor:
    lutTable:
      - '00 = 1'
      - '01 = 0'
      - '10 = 0'
      - '11 = 1'
  # lut equal
  equal:
    lutTable:
      - '-- = 1'
      - '-0 = 0'
      - '-1 = 0'
      - '0- = 0'
      - '00 = 1'
      - '01 = 0'
      - '1- = 0'
      - '10 = 0'
      - '11 = 1'
  # lut isMin
  isMin:
    lutTable:
      - '- = 1'
      - '0 = 0'
      - '1 = 0'
  # lut isNegative
  isNegative:
    lutTable:
      - '- = 1'
      - '0 = 0'
      - '1 = 0'
  # lut isOne
  isOne:
    lutTable:
      - '- = 0'
      - '0 = 0'
      - '1 = 1'
  # lut isPositive
  isPositive:
    lutTable:
      - '- = 0'
      - '0 = 0'
      - '1 = 1'
  # lut isZero
  isZero:
    lutTable:
      - '- = 0'
      - '0 = 1'
      - '1 = 0'
  # lut notNegative
  notNegative:
    lutTable:
      - '- = 0'
      - '0 = 1'
      - '1 = 1'
  # lut notPositive
  notPositive:
    lutTable:
      - '- = 1'
      - '0 = 1'
      - '1 = 0'
  # lut notZero
  notZero:
    lutTable:
      - '- = 1'
      - '0 = 0'
      - '1 = 1'
  # lut cmp
  cmp:
    lutTable:
      - '-- = 0'
      - '0- = 1'
      - '1- = 1'
      - '-0 = -'
      - '00 = 0'
      - '10 = 1'
      - '-1 = -'
      - '01 = -'
      - '11 = 0'
  # lut isLess
  isLess:
    lutTable:
      - '- = 1'
      - '0 = 0'
      - '1 = 0'
  # lut isGreater
  isGreater:
    lutTable:
      - '- = 0'
      - '0 = 0'
      - '1 = 1'
  # lut isEqual
  isEqual:
    lutTable:
      - '- = 0'
      - '0 = 1'
      - '1 = 0'
  # lut notLess
  notLess:
    lutTable:
      - '- = 0'
      - '0 = 1'
      - '1 = 1'
  # lut notGreater
  notGreater:
    lutTable:
      - '- = 1'
      - '0 = 1'
      - '1 = 0'
  # lut notEqual
  notEqual:
    lutTable:
      - '- = 1'
      - '0 = 0'
      - '1 = 1'
  # lut even
  even:
    lutTable:
      - '--- = 0'
      - '0-- = 1'
      - '1-- = 0'
      - '-0- = 1'
      - '00- = 0'
      - '10- = 1'
      - '-1- = 0'
      - '01- = 1'
      - '11- = 0'
      - '--0 = 1'
      - '0-0 = 0'
      - '1-0 = 1'
      - '-00 = 0'
      - '000 = 1'
      - '100 = 0'
      - '-10 = 1'
      - '010 = 0'
      - '110 = 1'
      - '--1 = 0'
      - '0-1 = 1'
      - '1-1 = 0'
      - '-01 = 1'
      - '001 = 0'
      - '101 = 1'
      - '-11 = 0'
      - '011 = 1'
      - '111 = 0'
  # lut fullAdd
  fullAdd:
    lutTable:
      - '--- = 0-'
      - '--0 = 1-'
      - '--1 = -0'
      - '-0- = 1-'
      - '-00 = -0'
      - '-01 = 00'
      - '-1- = -0'
      - '-10 = 00'
      - '-11 = 10'
      - '0-- = 1-'
      - '0-0 = -0'
      - '0-1 = 00'
      - '00- = -0'
      - '000 = 00'
      - '001 = 10'
      - '01- = 00'
      - '010 = 10'
      - '011 = -1'
      - '1-- = -0'
      - '1-0 = 00'
      - '1-1 = 10'
      - '10- = 00'
      - '100 = 10'
      - '101 = -1'
      - '11- = 10'
      - '110 = -1'
      - '111 = 01'
  # lut fullMul
  fullMul:
    lutTable:
      - '-- = 1'
      - '-0 = 0'
      - '-1 = -'
      - '0- = 0'
      - '00 = 0'
      - '01 = 0'
      - '1- = -'
      - '10 = 0'
      - '11 = 1'
  # lut halfAdd
  halfAdd:
    lutTable:
      - '-- = 1-'
      - '-0 = -0'
      - '-1 = 00'
      - '0- = -0'
      - '00 = 00'
      - '01 = 10'
      - '1- = 00'
      - '10 = 10'
      - '11 = -1'
  # lut neg
  neg:
    lutTable:
      - '- = 1'
      - '0 = 0'
      - '1 = -'
  # lut sign
  sign:
    lutTable:
      - '--- = -'
      - '0-- = -'
      - '1-- = -'
      - '-0- = -'
      - '00- = -'
      - '10- = -'
      - '-1- = -'
      - '01- = -'
      - '11- = -'
      - '--0 = -'
      - '0-0 = -'
      - '1-0 = -'
      - '-00 = -'
      - '000 = 0'
      - '100 = 1'
      - '-10 = 1'
      - '010 = 1'
      - '110 = 1'
      - '--1 = 1'
      - '0-1 = 1'
      - '1-1 = 1'
      - '-01 = 1'
      - '001 = 1'
      - '101 = 1'
      - '-11 = 1'
      - '011 = 1'
      - '111 = 1'
  # lut unequal
  unequal:
    lutTable:
      - '-- = 0'
      - '-0 = 1'
      - '-1 = 1'
      - '0- = 1'
      - '00 = 0'
      - '01 = 1'
      - '1- = 1'
      - '10 = 1'
      - '11 = 0'
functions: 
# 
# func Trit all<Trit>(Trit val) {
#   return val
# }
  all_1:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 1
# 
# func Bool equal<Trit>(Trit lhs, Trit rhs) {
#   return equal[lhs, rhs]
# }
  equal_1:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: lhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: rhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # equal[lhs, rhs]
      LutExpr:
        name: equal
        args: 
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 1
# 
# func Trit cmp<Trit>(Trit lhs, Trit rhs) {
#   return cmp[lhs, rhs]
# }
  cmp_1:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: rhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # cmp[lhs, rhs]
      LutExpr:
        name: cmp
        args: 
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 1
# 
# func Bool even<Trit>(Trit val) {
#   return even[val, 0, 0]
# }
  even_1:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: val
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # even[val, 0, 0]
      LutExpr:
        name: even
        args: 
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
# 
# func Bool even<Tryte>(Tryte val) {
#   return even[val[0], val[1], val[2]]
# }
  even_3:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: val
        size: 3
        type: 
          ConstTypeName:
            typeName: Tryte
            size: 3
    return: 
    # even[val[0], val[1], val[2]]
      LutExpr:
        name: even
        args: 
          - 
            SliceExpr:
              source: 'val[0]'
              var: val
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
          - 
            SliceExpr:
              source: 'val[1]'
              var: val
              offset: 1
              size: 1
              start:
                ConstNumber:
                  value: 1
          - 
            SliceExpr:
              source: 'val[2]'
              var: val
              offset: 2
              size: 1
              start:
                ConstNumber:
                  value: 2
# 
# func TritCarry fullAdd<Trit>(Trit lhs, Trit rhs, Carry carry) {
#   return fullAdd[lhs, rhs, carry]
# }
  fullAdd_1:
    returnType: 
      ConstTypeName:
        typeName: TritCarry
        size: 2
        fields:
          value: 
            size: '1'
            offset: '0'
          carry: 
            size: '1'
            offset: '1'
    params:
      - 
        argName: lhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: rhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    return: 
    # fullAdd[lhs, rhs, carry]
      LutExpr:
        name: fullAdd
        args: 
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
# 
# func TritCarry fullMul<Trit>(Trit lhs, Trit rhs) {
#   return fullMul[lhs, rhs] & 0
# }
  fullMul_1:
    returnType: 
      ConstTypeName:
        typeName: TritCarry
        size: 2
        fields:
          value: 
            size: '1'
            offset: '0'
          carry: 
            size: '1'
            offset: '1'
    params:
      - 
        argName: lhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: rhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # fullMul[lhs, rhs] & 0
      ConcatExpr:
        source: 'fullMul[lhs, rhs] & 0'
        lhs: 
          LutExpr:
            name: fullMul
            args: 
              - 
                SliceExpr:
                  source: 'lhs'
                  var: lhs
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhs'
                  var: rhs
                  offset: 0
                  size: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func TritCarry fullMulNonZero<Trit>(Trit lhs, Trit rhs) {
#   return fullMul[lhs, rhs] & 0
# }
  fullMulNonZero_1:
    returnType: 
      ConstTypeName:
        typeName: TritCarry
        size: 2
        fields:
          value: 
            size: '1'
            offset: '0'
          carry: 
            size: '1'
            offset: '1'
    params:
      - 
        argName: lhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: rhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # fullMul[lhs, rhs] & 0
      ConcatExpr:
        source: 'fullMul[lhs, rhs] & 0'
        lhs: 
          LutExpr:
            name: fullMul
            args: 
              - 
                SliceExpr:
                  source: 'lhs'
                  var: lhs
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhs'
                  var: rhs
                  offset: 0
                  size: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func TritCarry halfAdd<Trit>(Trit val, Carry carry) {
#   return halfAdd[val, carry]
# }
  halfAdd_1:
    returnType: 
      ConstTypeName:
        typeName: TritCarry
        size: 2
        fields:
          value: 
            size: '1'
            offset: '0'
          carry: 
            size: '1'
            offset: '1'
    params:
      - 
        argName: val
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    return: 
    # halfAdd[val, carry]
      LutExpr:
        name: halfAdd
        args: 
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
# 
# func Trit neg<Trit>(Trit val) {
#   return neg[val]
# }
  neg_1:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # neg[val]
      LutExpr:
        name: neg
        args: 
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 1
# 
# func Trit sign<Trit>(Trit val) {
#   return val
# }
  sign_1:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 1
# 
# func Bool unequal<Trit>(Trit lhs, Trit rhs) {
#   return unequal[lhs, rhs]
# }
  unequal_1:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: lhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
      - 
        argName: rhs
        size: 1
        type: 
          ConstTypeName:
            typeName: Trit
            size: 1
    return: 
    # unequal[lhs, rhs]
      LutExpr:
        name: unequal
        args: 
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 1
# 
# func Int firstOne(Int val) {
#   affect first
#   return val
# }
  firstOne:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    env: 
      - 
        name: first
        type: affect
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 27
# 
# func Int nextOne(Int val) {
#   join first
#   affect second
#   return val
# }
  nextOne:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    env: 
      - 
        name: first
        type: join
      - 
        name: second
        type: affect
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 27
# 
# func Int lastOne(Int val) {
#   join second
#   return val
# }
  lastOne:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    env: 
      - 
        name: second
        type: join
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 27
# 
# func Int bin2trin<Int>(Int val) {
#   return bin2trin2<Int>(val, 0, 1)
# }
  bin2trin_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # bin2trin2<Int>(val, 0, 1)
      FuncExpr:
        source: 'bin2trin2<Int>(val, 0, 1)'
        name: bin2trin2_27
        args:
        - 
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 27
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000'
              trytes: '999999999'
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
# 
# func Int bin2trin2<Int>(Int remain, Int sum, Int power) {
#   newSum = isOne[remain[0]] ? add<Int>(sum, power) : sum
#   done = isZero[sign<Int>(remain)]
#   return done ? sum : bin2trin2<Int>(lshift<Int>(remain), newSum, add<Int>(power, power))
# }
  bin2trin2_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: remain
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: sum
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: power
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      newSum:
        CondExpr:
          source: 'isOne[remain[0]] ? add<Int>(sum, power) : sum'
          if: 
            LutExpr:
              name: isOne
              args: 
                - 
                  SliceExpr:
                    source: 'remain[0]'
                    var: remain
                    offset: 0
                    size: 1
                    start:
                      ConstNumber:
                        value: 0
          then: 
            FuncExpr:
              source: 'add<Int>(sum, power)'
              name: add_27
              args:
              - 
                SliceExpr:
                  source: 'sum'
                  var: sum
                  offset: 0
                  size: 27
              - 
                SliceExpr:
                  source: 'power'
                  var: power
                  offset: 0
                  size: 27
          else:
            SliceExpr:
              source: 'sum'
              var: sum
              offset: 0
              size: 27
      done:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Int>(remain)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 27
    return: 
    # done ? sum : bin2trin2<Int>(lshift<Int>(remain), newSum, add<Int>(power, power))
      CondExpr:
        source: 'done ? sum : bin2trin2<Int>(lshift<Int>(remain), newSum, add<Int>(power, power))'
        if: 
          SliceExpr:
            source: 'done'
            var: done
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'sum'
            var: sum
            offset: 0
            size: 27
        else:
          FuncExpr:
            source: 'bin2trin2<Int>(lshift<Int>(remain), newSum, add<Int>(power, power))'
            name: bin2trin2_27
            args:
            - 
              FuncExpr:
                source: 'lshift<Int>(remain)'
                name: lshift_27
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 27
            - 
              SliceExpr:
                source: 'newSum'
                var: newSum
                offset: 0
                size: 27
            - 
              FuncExpr:
                source: 'add<Int>(power, power)'
                name: add_27
                args:
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 27
# 
# func Int add<Int>(Int lhs, Int rhs) {
#   sum = fullAdd<Int>(lhs, rhs, 0)
#   return sum.value
# }
  add_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Int>(lhs, rhs, 0)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 27
        fields: 
          - value
# 
# func TCarry fullAdd<Int>(Int lhs, Int rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_27:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 28
        fields:
          value: 
            size: '27'
            offset: '0'
          carry: 
            size: '1'
            offset: '27'
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 9
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 9
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 9
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 9
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 10
# 
# func TCarry fullAdd<A>(A lhs, A rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_9:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 10
        fields:
          value: 
            size: '9'
            offset: '0'
          carry: 
            size: '1'
            offset: '9'
    params:
      - 
        argName: lhs
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
      - 
        argName: rhs
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 3
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 3
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 3
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 3
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 4
# 
# func TCarry fullAdd<A>(A lhs, A rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_3:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 4
        fields:
          value: 
            size: '3'
            offset: '0'
          carry: 
            size: '1'
            offset: '3'
    params:
      - 
        argName: lhs
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
      - 
        argName: rhs
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 1
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 1
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 1
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 1
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 2
# 
# func Trit sign<Int>(Int val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_27:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_9
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_9
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_9
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Trit sign<A>(A val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_9:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_3
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_3
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_3
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Trit sign<A>(A val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_3:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_1
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_1
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_1
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Int lshift<Int>(Int val) {
#   return val[1 : Int - 1] & 0
# }
  lshift_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # val[1 : Int - 1] & 0
      ConcatExpr:
        source: 'val[1 : Int - 1] & 0'
        lhs: 
          SliceExpr:
            source: 'val[1 : Int - 1]'
            var: val
            offset: 1
            size: 26
            start:
              ConstNumber:
                value: 1
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Int
                    size: 27
                rhs: 
                  ConstNumber:
                    value: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func Huge bin2trin<Huge>(Huge val) {
#   return bin2trin2<Huge>(val, 0, 1)
# }
  bin2trin_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # bin2trin2<Huge>(val, 0, 1)
      FuncExpr:
        source: 'bin2trin2<Huge>(val, 0, 1)'
        name: bin2trin2_81
        args:
        - 
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 81
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999'
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'A99999999999999999999999999'
# 
# func Huge bin2trin2<Huge>(Huge remain, Huge sum, Huge power) {
#   newSum = isOne[remain[0]] ? add<Huge>(sum, power) : sum
#   done = isZero[sign<Huge>(remain)]
#   return done ? sum : bin2trin2<Huge>(lshift<Huge>(remain), newSum, add<Huge>(power, power))
# }
  bin2trin2_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: remain
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: sum
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: power
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      newSum:
        CondExpr:
          source: 'isOne[remain[0]] ? add<Huge>(sum, power) : sum'
          if: 
            LutExpr:
              name: isOne
              args: 
                - 
                  SliceExpr:
                    source: 'remain[0]'
                    var: remain
                    offset: 0
                    size: 1
                    start:
                      ConstNumber:
                        value: 0
          then: 
            FuncExpr:
              source: 'add<Huge>(sum, power)'
              name: add_81
              args:
              - 
                SliceExpr:
                  source: 'sum'
                  var: sum
                  offset: 0
                  size: 81
              - 
                SliceExpr:
                  source: 'power'
                  var: power
                  offset: 0
                  size: 81
          else:
            SliceExpr:
              source: 'sum'
              var: sum
              offset: 0
              size: 81
      done:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(remain)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 81
    return: 
    # done ? sum : bin2trin2<Huge>(lshift<Huge>(remain), newSum, add<Huge>(power, power))
      CondExpr:
        source: 'done ? sum : bin2trin2<Huge>(lshift<Huge>(remain), newSum, add<Huge>(power, power))'
        if: 
          SliceExpr:
            source: 'done'
            var: done
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'sum'
            var: sum
            offset: 0
            size: 81
        else:
          FuncExpr:
            source: 'bin2trin2<Huge>(lshift<Huge>(remain), newSum, add<Huge>(power, power))'
            name: bin2trin2_81
            args:
            - 
              FuncExpr:
                source: 'lshift<Huge>(remain)'
                name: lshift_81
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 81
            - 
              SliceExpr:
                source: 'newSum'
                var: newSum
                offset: 0
                size: 81
            - 
              FuncExpr:
                source: 'add<Huge>(power, power)'
                name: add_81
                args:
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 81
# 
# func Huge add<Huge>(Huge lhs, Huge rhs) {
#   sum = fullAdd<Huge>(lhs, rhs, 0)
#   return sum.value
# }
  add_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Huge>(lhs, rhs, 0)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 81
        fields: 
          - value
# 
# func TCarry fullAdd<Huge>(Huge lhs, Huge rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_81:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 82
        fields:
          value: 
            size: '81'
            offset: '0'
          carry: 
            size: '1'
            offset: '81'
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 27
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 27
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 27
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 27
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 28
# 
# func Trit sign<Huge>(Huge val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_81:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Huge lshift<Huge>(Huge val) {
#   return val[1 : Huge - 1] & 0
# }
  lshift_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # val[1 : Huge - 1] & 0
      ConcatExpr:
        source: 'val[1 : Huge - 1] & 0'
        lhs: 
          SliceExpr:
            source: 'val[1 : Huge - 1]'
            var: val
            offset: 1
            size: 80
            start:
              ConstNumber:
                value: 1
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Huge
                    size: 81
                rhs: 
                  ConstNumber:
                    value: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func Hash bin2trin<Hash>(Hash val) {
#   return bin2trin2<Hash>(val, 0, 1)
# }
  bin2trin_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: val
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    return: 
    # bin2trin2<Hash>(val, 0, 1)
      FuncExpr:
        source: 'bin2trin2<Hash>(val, 0, 1)'
        name: bin2trin2_243
        args:
        - 
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 243
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999999999999999999999999999999999999999999999999999999999'
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'A99999999999999999999999999999999999999999999999999999999999999999999999999999999'
# 
# func Hash bin2trin2<Hash>(Hash remain, Hash sum, Hash power) {
#   newSum = isOne[remain[0]] ? add<Hash>(sum, power) : sum
#   done = isZero[sign<Hash>(remain)]
#   return done ? sum : bin2trin2<Hash>(lshift<Hash>(remain), newSum, add<Hash>(power, power))
# }
  bin2trin2_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: remain
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: sum
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: power
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      newSum:
        CondExpr:
          source: 'isOne[remain[0]] ? add<Hash>(sum, power) : sum'
          if: 
            LutExpr:
              name: isOne
              args: 
                - 
                  SliceExpr:
                    source: 'remain[0]'
                    var: remain
                    offset: 0
                    size: 1
                    start:
                      ConstNumber:
                        value: 0
          then: 
            FuncExpr:
              source: 'add<Hash>(sum, power)'
              name: add_243
              args:
              - 
                SliceExpr:
                  source: 'sum'
                  var: sum
                  offset: 0
                  size: 243
              - 
                SliceExpr:
                  source: 'power'
                  var: power
                  offset: 0
                  size: 243
          else:
            SliceExpr:
              source: 'sum'
              var: sum
              offset: 0
              size: 243
      done:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash>(remain)'
                name: sign_243
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 243
    return: 
    # done ? sum : bin2trin2<Hash>(lshift<Hash>(remain), newSum, add<Hash>(power, power))
      CondExpr:
        source: 'done ? sum : bin2trin2<Hash>(lshift<Hash>(remain), newSum, add<Hash>(power, power))'
        if: 
          SliceExpr:
            source: 'done'
            var: done
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'sum'
            var: sum
            offset: 0
            size: 243
        else:
          FuncExpr:
            source: 'bin2trin2<Hash>(lshift<Hash>(remain), newSum, add<Hash>(power, power))'
            name: bin2trin2_243
            args:
            - 
              FuncExpr:
                source: 'lshift<Hash>(remain)'
                name: lshift_243
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 243
            - 
              SliceExpr:
                source: 'newSum'
                var: newSum
                offset: 0
                size: 243
            - 
              FuncExpr:
                source: 'add<Hash>(power, power)'
                name: add_243
                args:
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 243
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 243
# 
# func Hash add<Hash>(Hash lhs, Hash rhs) {
#   sum = fullAdd<Hash>(lhs, rhs, 0)
#   return sum.value
# }
  add_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: lhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: rhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Hash>(lhs, rhs, 0)'
          name: fullAdd_243
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 243
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 243
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 243
        fields: 
          - value
# 
# func TCarry fullAdd<Hash>(Hash lhs, Hash rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_243:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 244
        fields:
          value: 
            size: '243'
            offset: '0'
          carry: 
            size: '1'
            offset: '243'
    params:
      - 
        argName: lhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: rhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 81
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 81
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 81
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 81
              size: 81
              start:
                ConstTypeName:
                  typeName: A
                  size: 81
              end:
                ConstTypeName:
                  typeName: B
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 81
              size: 81
              start:
                ConstTypeName:
                  typeName: A
                  size: 81
              end:
                ConstTypeName:
                  typeName: B
                  size: 81
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 81
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 162
              size: 81
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 81
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 81
              end:
                ConstTypeName:
                  typeName: C
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 162
              size: 81
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 81
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 81
              end:
                ConstTypeName:
                  typeName: C
                  size: 81
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 81
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 81
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 81
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 82
# 
# func Trit sign<Hash>(Hash val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_243:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 81
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 81
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 81
              size: 81
              start:
                ConstTypeName:
                  typeName: A
                  size: 81
              end:
                ConstTypeName:
                  typeName: B
                  size: 81
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 162
              size: 81
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 81
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 81
              end:
                ConstTypeName:
                  typeName: C
                  size: 81
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Hash lshift<Hash>(Hash val) {
#   return val[1 : Hash - 1] & 0
# }
  lshift_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: val
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    return: 
    # val[1 : Hash - 1] & 0
      ConcatExpr:
        source: 'val[1 : Hash - 1] & 0'
        lhs: 
          SliceExpr:
            source: 'val[1 : Hash - 1]'
            var: val
            offset: 1
            size: 242
            start:
              ConstNumber:
                value: 1
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Hash
                    size: 243
                rhs: 
                  ConstNumber:
                    value: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func Hash3 bin2trin<Hash3>(Hash3 val) {
#   return bin2trin2<Hash3>(val, 0, 1)
# }
  bin2trin_729:
    returnType: 
      ConstTypeName:
        typeName: Hash3
        size: 729
    params:
      - 
        argName: val
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
    return: 
    # bin2trin2<Hash3>(val, 0, 1)
      FuncExpr:
        source: 'bin2trin2<Hash3>(val, 0, 1)'
        name: bin2trin2_729
        args:
        - 
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 729
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'A99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
# 
# func Hash3 bin2trin2<Hash3>(Hash3 remain, Hash3 sum, Hash3 power) {
#   newSum = isOne[remain[0]] ? add<Hash3>(sum, power) : sum
#   done = isZero[sign<Hash3>(remain)]
#   return done ? sum : bin2trin2<Hash3>(lshift<Hash3>(remain), newSum, add<Hash3>(power, power))
# }
  bin2trin2_729:
    returnType: 
      ConstTypeName:
        typeName: Hash3
        size: 729
    params:
      - 
        argName: remain
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
      - 
        argName: sum
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
      - 
        argName: power
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
    assigns: 
      newSum:
        CondExpr:
          source: 'isOne[remain[0]] ? add<Hash3>(sum, power) : sum'
          if: 
            LutExpr:
              name: isOne
              args: 
                - 
                  SliceExpr:
                    source: 'remain[0]'
                    var: remain
                    offset: 0
                    size: 1
                    start:
                      ConstNumber:
                        value: 0
          then: 
            FuncExpr:
              source: 'add<Hash3>(sum, power)'
              name: add_729
              args:
              - 
                SliceExpr:
                  source: 'sum'
                  var: sum
                  offset: 0
                  size: 729
              - 
                SliceExpr:
                  source: 'power'
                  var: power
                  offset: 0
                  size: 729
          else:
            SliceExpr:
              source: 'sum'
              var: sum
              offset: 0
              size: 729
      done:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash3>(remain)'
                name: sign_729
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 729
    return: 
    # done ? sum : bin2trin2<Hash3>(lshift<Hash3>(remain), newSum, add<Hash3>(power, power))
      CondExpr:
        source: 'done ? sum : bin2trin2<Hash3>(lshift<Hash3>(remain), newSum, add<Hash3>(power, power))'
        if: 
          SliceExpr:
            source: 'done'
            var: done
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'sum'
            var: sum
            offset: 0
            size: 729
        else:
          FuncExpr:
            source: 'bin2trin2<Hash3>(lshift<Hash3>(remain), newSum, add<Hash3>(power, power))'
            name: bin2trin2_729
            args:
            - 
              FuncExpr:
                source: 'lshift<Hash3>(remain)'
                name: lshift_729
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 729
            - 
              SliceExpr:
                source: 'newSum'
                var: newSum
                offset: 0
                size: 729
            - 
              FuncExpr:
                source: 'add<Hash3>(power, power)'
                name: add_729
                args:
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 729
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 729
# 
# func Hash3 add<Hash3>(Hash3 lhs, Hash3 rhs) {
#   sum = fullAdd<Hash3>(lhs, rhs, 0)
#   return sum.value
# }
  add_729:
    returnType: 
      ConstTypeName:
        typeName: Hash3
        size: 729
    params:
      - 
        argName: lhs
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
      - 
        argName: rhs
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Hash3>(lhs, rhs, 0)'
          name: fullAdd_729
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 729
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 729
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 729
        fields: 
          - value
# 
# func TCarry fullAdd<Hash3>(Hash3 lhs, Hash3 rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_729:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 730
        fields:
          value: 
            size: '729'
            offset: '0'
          carry: 
            size: '1'
            offset: '729'
    params:
      - 
        argName: lhs
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
      - 
        argName: rhs
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_243
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 243
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 243
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 243
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 243
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_243
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 243
              size: 243
              start:
                ConstTypeName:
                  typeName: A
                  size: 243
              end:
                ConstTypeName:
                  typeName: B
                  size: 243
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 243
              size: 243
              start:
                ConstTypeName:
                  typeName: A
                  size: 243
              end:
                ConstTypeName:
                  typeName: B
                  size: 243
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 243
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_243
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 486
              size: 243
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 243
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 243
              end:
                ConstTypeName:
                  typeName: C
                  size: 243
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 486
              size: 243
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 243
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 243
              end:
                ConstTypeName:
                  typeName: C
                  size: 243
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 243
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 243
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 243
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 244
# 
# func Trit sign<Hash3>(Hash3 val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_729:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_243
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 243
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 243
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_243
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 243
              size: 243
              start:
                ConstTypeName:
                  typeName: A
                  size: 243
              end:
                ConstTypeName:
                  typeName: B
                  size: 243
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_243
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 486
              size: 243
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 243
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 243
              end:
                ConstTypeName:
                  typeName: C
                  size: 243
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Hash3 lshift<Hash3>(Hash3 val) {
#   return val[1 : Hash3 - 1] & 0
# }
  lshift_729:
    returnType: 
      ConstTypeName:
        typeName: Hash3
        size: 729
    params:
      - 
        argName: val
        size: 729
        type: 
          ConstTypeName:
            typeName: Hash3
            size: 729
    return: 
    # val[1 : Hash3 - 1] & 0
      ConcatExpr:
        source: 'val[1 : Hash3 - 1] & 0'
        lhs: 
          SliceExpr:
            source: 'val[1 : Hash3 - 1]'
            var: val
            offset: 1
            size: 728
            start:
              ConstNumber:
                value: 1
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Hash3
                    size: 729
                rhs: 
                  ConstNumber:
                    value: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func Hash9 bin2trin<Hash9>(Hash9 val) {
#   return bin2trin2<Hash9>(val, 0, 1)
# }
  bin2trin_2187:
    returnType: 
      ConstTypeName:
        typeName: Hash9
        size: 2187
    params:
      - 
        argName: val
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
    return: 
    # bin2trin2<Hash9>(val, 0, 1)
      FuncExpr:
        source: 'bin2trin2<Hash9>(val, 0, 1)'
        name: bin2trin2_2187
        args:
        - 
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 2187
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'A99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
# 
# func Hash9 bin2trin2<Hash9>(Hash9 remain, Hash9 sum, Hash9 power) {
#   newSum = isOne[remain[0]] ? add<Hash9>(sum, power) : sum
#   done = isZero[sign<Hash9>(remain)]
#   return done ? sum : bin2trin2<Hash9>(lshift<Hash9>(remain), newSum, add<Hash9>(power, power))
# }
  bin2trin2_2187:
    returnType: 
      ConstTypeName:
        typeName: Hash9
        size: 2187
    params:
      - 
        argName: remain
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
      - 
        argName: sum
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
      - 
        argName: power
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
    assigns: 
      newSum:
        CondExpr:
          source: 'isOne[remain[0]] ? add<Hash9>(sum, power) : sum'
          if: 
            LutExpr:
              name: isOne
              args: 
                - 
                  SliceExpr:
                    source: 'remain[0]'
                    var: remain
                    offset: 0
                    size: 1
                    start:
                      ConstNumber:
                        value: 0
          then: 
            FuncExpr:
              source: 'add<Hash9>(sum, power)'
              name: add_2187
              args:
              - 
                SliceExpr:
                  source: 'sum'
                  var: sum
                  offset: 0
                  size: 2187
              - 
                SliceExpr:
                  source: 'power'
                  var: power
                  offset: 0
                  size: 2187
          else:
            SliceExpr:
              source: 'sum'
              var: sum
              offset: 0
              size: 2187
      done:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash9>(remain)'
                name: sign_2187
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 2187
    return: 
    # done ? sum : bin2trin2<Hash9>(lshift<Hash9>(remain), newSum, add<Hash9>(power, power))
      CondExpr:
        source: 'done ? sum : bin2trin2<Hash9>(lshift<Hash9>(remain), newSum, add<Hash9>(power, power))'
        if: 
          SliceExpr:
            source: 'done'
            var: done
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'sum'
            var: sum
            offset: 0
            size: 2187
        else:
          FuncExpr:
            source: 'bin2trin2<Hash9>(lshift<Hash9>(remain), newSum, add<Hash9>(power, power))'
            name: bin2trin2_2187
            args:
            - 
              FuncExpr:
                source: 'lshift<Hash9>(remain)'
                name: lshift_2187
                args:
                - 
                  SliceExpr:
                    source: 'remain'
                    var: remain
                    offset: 0
                    size: 2187
            - 
              SliceExpr:
                source: 'newSum'
                var: newSum
                offset: 0
                size: 2187
            - 
              FuncExpr:
                source: 'add<Hash9>(power, power)'
                name: add_2187
                args:
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 2187
                - 
                  SliceExpr:
                    source: 'power'
                    var: power
                    offset: 0
                    size: 2187
# 
# func Hash9 add<Hash9>(Hash9 lhs, Hash9 rhs) {
#   sum = fullAdd<Hash9>(lhs, rhs, 0)
#   return sum.value
# }
  add_2187:
    returnType: 
      ConstTypeName:
        typeName: Hash9
        size: 2187
    params:
      - 
        argName: lhs
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
      - 
        argName: rhs
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Hash9>(lhs, rhs, 0)'
          name: fullAdd_2187
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 2187
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 2187
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 2187
        fields: 
          - value
# 
# func TCarry fullAdd<Hash9>(Hash9 lhs, Hash9 rhs, Carry carry) {
#   add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
#   add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
#   add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  fullAdd_2187:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 2188
        fields:
          value: 
            size: '2187'
            offset: '0'
          carry: 
            size: '1'
            offset: '2187'
    params:
      - 
        argName: lhs
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
      - 
        argName: rhs
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)'
          name: fullAdd_729
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 729
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 729
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 729
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 729
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)'
          name: fullAdd_729
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 729
              size: 729
              start:
                ConstTypeName:
                  typeName: A
                  size: 729
              end:
                ConstTypeName:
                  typeName: B
                  size: 729
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 729
              size: 729
              start:
                ConstTypeName:
                  typeName: A
                  size: 729
              end:
                ConstTypeName:
                  typeName: B
                  size: 729
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 729
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)'
          name: fullAdd_729
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 1458
              size: 729
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 729
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 729
              end:
                ConstTypeName:
                  typeName: C
                  size: 729
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 1458
              size: 729
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 729
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 729
              end:
                ConstTypeName:
                  typeName: C
                  size: 729
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 729
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 729
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 729
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 730
# 
# func Trit sign<Hash9>(Hash9 val) {
#   val0 = sign<A>(val[0 : A])
#   val1 = sign<B>(val[A : B])
#   val2 = sign<C>(val[A + B : C])
#   return sign[val0, val1, val2]
# }
  sign_2187:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: val
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
    assigns: 
      val0:
        FuncExpr:
          source: 'sign<A>(val[0 : A])'
          name: sign_729
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 729
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 729
      val1:
        FuncExpr:
          source: 'sign<B>(val[A : B])'
          name: sign_729
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 729
              size: 729
              start:
                ConstTypeName:
                  typeName: A
                  size: 729
              end:
                ConstTypeName:
                  typeName: B
                  size: 729
      val2:
        FuncExpr:
          source: 'sign<C>(val[A + B : C])'
          name: sign_729
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 1458
              size: 729
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 729
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 729
              end:
                ConstTypeName:
                  typeName: C
                  size: 729
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Hash9 lshift<Hash9>(Hash9 val) {
#   return val[1 : Hash9 - 1] & 0
# }
  lshift_2187:
    returnType: 
      ConstTypeName:
        typeName: Hash9
        size: 2187
    params:
      - 
        argName: val
        size: 2187
        type: 
          ConstTypeName:
            typeName: Hash9
            size: 2187
    return: 
    # val[1 : Hash9 - 1] & 0
      ConcatExpr:
        source: 'val[1 : Hash9 - 1] & 0'
        lhs: 
          SliceExpr:
            source: 'val[1 : Hash9 - 1]'
            var: val
            offset: 1
            size: 2186
            start:
              ConstNumber:
                value: 1
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Hash9
                    size: 2187
                rhs: 
                  ConstNumber:
                    value: 1
        rhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
# 
# func Tiny factorial<Tiny>(Tiny n) {
#   isZero = isZero[sign<Tiny>(n)]
#   return isZero ? 1 : mul<Tiny>(n, factorial<Tiny>(decr<Tiny>(n)))
# }
  factorial_9:
    returnType: 
      ConstTypeName:
        typeName: Tiny
        size: 9
    params:
      - 
        argName: n
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
    assigns: 
      isZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Tiny>(n)'
                name: sign_9
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 9
    return: 
    # isZero ? 1 : mul<Tiny>(n, factorial<Tiny>(decr<Tiny>(n)))
      CondExpr:
        source: 'isZero ? 1 : mul<Tiny>(n, factorial<Tiny>(decr<Tiny>(n)))'
        if: 
          SliceExpr:
            source: 'isZero'
            var: isZero
            offset: 0
            size: 1
        then: 
          ValueExpr:
              value: '1'
              trits: '100000000'
              trytes: 'A99'
        else:
          FuncExpr:
            source: 'mul<Tiny>(n, factorial<Tiny>(decr<Tiny>(n)))'
            name: mul_9
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 9
            - 
              FuncExpr:
                source: 'factorial<Tiny>(decr<Tiny>(n))'
                name: factorial_9
                args:
                - 
                  FuncExpr:
                    source: 'decr<Tiny>(n)'
                    name: decr_9
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 9
# 
# func Tiny mul<Tiny>(Tiny lhs, Tiny rhs) {
#   lhsZero = isZero[sign<Tiny>(lhs)]
#   rhsZero = isZero[sign<Tiny>(rhs)]
#   product = fullMulNonZero<Tiny>(lhs, rhs)
#   return or[lhsZero, rhsZero] ? 0 : product[0 : Tiny]
# }
  mul_9:
    returnType: 
      ConstTypeName:
        typeName: Tiny
        size: 9
    params:
      - 
        argName: lhs
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
      - 
        argName: rhs
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Tiny>(lhs)'
                name: sign_9
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 9
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Tiny>(rhs)'
                name: sign_9
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 9
      product:
        FuncExpr:
          source: 'fullMulNonZero<Tiny>(lhs, rhs)'
          name: fullMulNonZero_9
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 9
    return: 
    # or[lhsZero, rhsZero] ? 0 : product[0 : Tiny]
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : product[0 : Tiny]'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000'
              trytes: '999'
        else:
          SliceExpr:
            source: 'product[0 : Tiny]'
            var: product
            offset: 0
            size: 9
            start:
              ConstNumber:
                value: 0
            end:
              ConstTypeName:
                typeName: Tiny
                size: 9
# 
# func T2 fullMul<Tiny>(Tiny lhs, Tiny rhs) {
#   lhsZero = isZero[sign<Tiny>(lhs)]
#   rhsZero = isZero[sign<Tiny>(rhs)]
#   return or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Tiny>(lhs, rhs)
# }
  fullMul_9:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 18
    params:
      - 
        argName: lhs
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
      - 
        argName: rhs
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Tiny>(lhs)'
                name: sign_9
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 9
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Tiny>(rhs)'
                name: sign_9
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 9
    return: 
    # or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Tiny>(lhs, rhs)
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Tiny>(lhs, rhs)'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000'
              trytes: '999999'
        else:
          FuncExpr:
            source: 'fullMulNonZero<Tiny>(lhs, rhs)'
            name: fullMulNonZero_9
            args:
            - 
              SliceExpr:
                source: 'lhs'
                var: lhs
                offset: 0
                size: 9
            - 
              SliceExpr:
                source: 'rhs'
                var: rhs
                offset: 0
                size: 9
# 
# func T2 fullMulNonZero<Tiny>(Tiny lhs, Tiny rhs) {
#   A = lhs[P * 0 : P]
#   B = lhs[P * 1 : P]
#   C = lhs[P * 2 : P]
#   D = rhs[P * 0 : P]
#   E = rhs[P * 1 : P]
#   F = rhs[P * 2 : P]
#   AD = fullMul<P>(A, D)
#   AE = fullMul<P>(A, E)
#   AF = fullMul<P>(A, F)
#   BD = fullMul<P>(B, D)
#   BE = fullMul<P>(B, E)
#   BF = fullMul<P>(B, F)
#   CD = fullMul<P>(C, D)
#   CE = fullMul<P>(C, E)
#   CF = fullMul<P>(C, F)
#   tryte0 = AD[P * 0 : P]
#   carry0 = AD[P * 1 : P]
#   AEBD = addProduct<P>(AE, BD)
#   AEBDc = addCarryToProduct<P>(AEBD.value, carry0, 0)
#   tryte1 = AEBDc[P * 0 : P]
#   carry1 = AEBDc[P * 1 : P]
#   AFBE = addProduct<P>(AF, BE)
#   AFBEc = addCarryToProduct<P>(AFBE.value, carry1, 0)
#   AFBEcCD = addProduct<P>(AFBEc, CD)
#   tryte2 = AFBEcCD[P * 0 : P]
#   carry2 = AFBEcCD[P * 1 : P]
#   BFCE = addProduct<P>(BF, CE)
#   BFCEc = addCarryToProduct<P>(BFCE.value, carry2, 0)
#   tryte3 = BFCEc[P * 0 : P]
#   carry3 = BFCEc[P * 1 : P]
#   CFc = addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)
#   return tryte0 & tryte1 & tryte2 & tryte3 & CFc
# }
  fullMulNonZero_9:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 18
    params:
      - 
        argName: lhs
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
      - 
        argName: rhs
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
    assigns: 
      A:
        SliceExpr:
          source: 'lhs[P * 0 : P]'
          var: lhs
          offset: 0
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 3
      B:
        SliceExpr:
          source: 'lhs[P * 1 : P]'
          var: lhs
          offset: 3
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 3
      C:
        SliceExpr:
          source: 'lhs[P * 2 : P]'
          var: lhs
          offset: 6
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 3
      D:
        SliceExpr:
          source: 'rhs[P * 0 : P]'
          var: rhs
          offset: 0
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 3
      E:
        SliceExpr:
          source: 'rhs[P * 1 : P]'
          var: rhs
          offset: 3
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 3
      F:
        SliceExpr:
          source: 'rhs[P * 2 : P]'
          var: rhs
          offset: 6
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 3
      AD:
        FuncExpr:
          source: 'fullMul<P>(A, D)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 3
      AE:
        FuncExpr:
          source: 'fullMul<P>(A, E)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 3
      AF:
        FuncExpr:
          source: 'fullMul<P>(A, F)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 3
      BD:
        FuncExpr:
          source: 'fullMul<P>(B, D)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 3
      BE:
        FuncExpr:
          source: 'fullMul<P>(B, E)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 3
      BF:
        FuncExpr:
          source: 'fullMul<P>(B, F)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 3
      CD:
        FuncExpr:
          source: 'fullMul<P>(C, D)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 3
      CE:
        FuncExpr:
          source: 'fullMul<P>(C, E)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 3
      CF:
        FuncExpr:
          source: 'fullMul<P>(C, F)'
          name: fullMul_3
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 3
      tryte0:
        SliceExpr:
          source: 'AD[P * 0 : P]'
          var: AD
          offset: 0
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 3
      carry0:
        SliceExpr:
          source: 'AD[P * 1 : P]'
          var: AD
          offset: 3
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 3
      AEBD:
        FuncExpr:
          source: 'addProduct<P>(AE, BD)'
          name: addProduct_3
          args:
          - 
            SliceExpr:
              source: 'AE'
              var: AE
              offset: 0
              size: 6
          - 
            SliceExpr:
              source: 'BD'
              var: BD
              offset: 0
              size: 6
      AEBDc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AEBD.value, carry0, 0)'
          name: addCarryToProduct_3
          args:
          - 
            SliceExpr:
              source: 'AEBD.value'
              var: AEBD
              offset: 0
              size: 6
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry0'
              var: carry0
              offset: 0
              size: 3
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte1:
        SliceExpr:
          source: 'AEBDc[P * 0 : P]'
          var: AEBDc
          offset: 0
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 3
      carry1:
        SliceExpr:
          source: 'AEBDc[P * 1 : P]'
          var: AEBDc
          offset: 3
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 3
      AFBE:
        FuncExpr:
          source: 'addProduct<P>(AF, BE)'
          name: addProduct_3
          args:
          - 
            SliceExpr:
              source: 'AF'
              var: AF
              offset: 0
              size: 6
          - 
            SliceExpr:
              source: 'BE'
              var: BE
              offset: 0
              size: 6
      AFBEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AFBE.value, carry1, 0)'
          name: addCarryToProduct_3
          args:
          - 
            SliceExpr:
              source: 'AFBE.value'
              var: AFBE
              offset: 0
              size: 6
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry1'
              var: carry1
              offset: 0
              size: 3
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      AFBEcCD:
        FuncExpr:
          source: 'addProduct<P>(AFBEc, CD)'
          name: addProduct_3
          args:
          - 
            SliceExpr:
              source: 'AFBEc'
              var: AFBEc
              offset: 0
              size: 6
          - 
            SliceExpr:
              source: 'CD'
              var: CD
              offset: 0
              size: 6
      tryte2:
        SliceExpr:
          source: 'AFBEcCD[P * 0 : P]'
          var: AFBEcCD
          offset: 0
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 3
      carry2:
        SliceExpr:
          source: 'AFBEcCD[P * 1 : P]'
          var: AFBEcCD
          offset: 3
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 3
      BFCE:
        FuncExpr:
          source: 'addProduct<P>(BF, CE)'
          name: addProduct_3
          args:
          - 
            SliceExpr:
              source: 'BF'
              var: BF
              offset: 0
              size: 6
          - 
            SliceExpr:
              source: 'CE'
              var: CE
              offset: 0
              size: 6
      BFCEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(BFCE.value, carry2, 0)'
          name: addCarryToProduct_3
          args:
          - 
            SliceExpr:
              source: 'BFCE.value'
              var: BFCE
              offset: 0
              size: 6
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry2'
              var: carry2
              offset: 0
              size: 3
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte3:
        SliceExpr:
          source: 'BFCEc[P * 0 : P]'
          var: BFCEc
          offset: 0
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 3
      carry3:
        SliceExpr:
          source: 'BFCEc[P * 1 : P]'
          var: BFCEc
          offset: 3
          size: 3
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 3
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 3
      CFc:
        FuncExpr:
          source: 'addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)'
          name: addCarryToProduct_3
          args:
          - 
            SliceExpr:
              source: 'CF'
              var: CF
              offset: 0
              size: 6
          - 
            SliceExpr:
              source: 'carry3'
              var: carry3
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'AFBEcCD.carry'
              var: AFBEcCD
              offset: 6
              size: 1
              fields: 
                - carry
    return: 
    # tryte0 & tryte1 & tryte2 & tryte3 & CFc
      ConcatExpr:
        source: 'tryte0 & tryte1 & tryte2 & tryte3 & CFc'
        lhs: 
          ConcatExpr:
            source: 'tryte0 & tryte1 & tryte2 & tryte3'
            lhs: 
              ConcatExpr:
                source: 'tryte0 & tryte1 & tryte2'
                lhs: 
                  ConcatExpr:
                    source: 'tryte0 & tryte1'
                    lhs: 
                      SliceExpr:
                        source: 'tryte0'
                        var: tryte0
                        offset: 0
                        size: 3
                    rhs: 
                      SliceExpr:
                        source: 'tryte1'
                        var: tryte1
                        offset: 0
                        size: 3
                rhs: 
                  SliceExpr:
                    source: 'tryte2'
                    var: tryte2
                    offset: 0
                    size: 3
            rhs: 
              SliceExpr:
                source: 'tryte3'
                var: tryte3
                offset: 0
                size: 3
        rhs: 
          SliceExpr:
            source: 'CFc'
            var: CFc
            offset: 0
            size: 6
# 
# func P2Carry addProduct<P>(P2 lhs, P2 rhs) {
#   lo = fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)
#   hi = fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)
#   return lo.value & hi
# }
  addProduct_3:
    returnType: 
      ConstTypeName:
        typeName: P2Carry
        size: 7
        fields:
          value: 
            size: '6'
            offset: '0'
          carry: 
            size: '1'
            offset: '6'
    params:
      - 
        argName: lhs
        size: 6
        type: 
          ConstTypeName:
            typeName: P2
            size: 6
      - 
        argName: rhs
        size: 6
        type: 
          ConstTypeName:
            typeName: P2
            size: 6
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)'
          name: fullAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 3
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 3
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[P * 0 : P]'
              var: rhs
              offset: 0
              size: 3
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 3
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 3
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      hi:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)'
          name: fullAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 3
              size: 3
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 3
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[P * 1 : P]'
              var: rhs
              offset: 3
              size: 3
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 3
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 3
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 3
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi
      ConcatExpr:
        source: 'lo.value & hi'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 3
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi'
            var: hi
            offset: 0
            size: 4
# 
# func P2 addCarryToProduct<P>(P2 lhs, P carry, Carry extraTrit) {
#   lo = fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)
#   hi = halfAdd<P>(lhs[P * 1 : P], lo.carry)
#   return lo.value & hi.value
# }
  addCarryToProduct_3:
    returnType: 
      ConstTypeName:
        typeName: P2
        size: 6
    params:
      - 
        argName: lhs
        size: 6
        type: 
          ConstTypeName:
            typeName: P2
            size: 6
      - 
        argName: carry
        size: 3
        type: 
          ConstTypeName:
            typeName: P
            size: 3
      - 
        argName: extraTrit
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)'
          name: fullAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 3
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 3
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 3
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 3
          - 
            SliceExpr:
              source: 'extraTrit'
              var: extraTrit
              offset: 0
              size: 1
      hi:
        FuncExpr:
          source: 'halfAdd<P>(lhs[P * 1 : P], lo.carry)'
          name: halfAdd_3
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 3
              size: 3
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 3
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 3
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 3
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi.value
      ConcatExpr:
        source: 'lo.value & hi.value'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 3
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi.value'
            var: hi
            offset: 0
            size: 3
            fields: 
              - value
# 
# func T2 fullMul<P>(P lhs, P rhs) {
#   lhsZero = isZero[sign<P>(lhs)]
#   rhsZero = isZero[sign<P>(rhs)]
#   return or[lhsZero, rhsZero] ? 0 : fullMulNonZero<P>(lhs, rhs)
# }
  fullMul_3:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 6
    params:
      - 
        argName: lhs
        size: 3
        type: 
          ConstTypeName:
            typeName: P
            size: 3
      - 
        argName: rhs
        size: 3
        type: 
          ConstTypeName:
            typeName: P
            size: 3
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<P>(lhs)'
                name: sign_3
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 3
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<P>(rhs)'
                name: sign_3
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 3
    return: 
    # or[lhsZero, rhsZero] ? 0 : fullMulNonZero<P>(lhs, rhs)
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : fullMulNonZero<P>(lhs, rhs)'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000'
              trytes: '99'
        else:
          FuncExpr:
            source: 'fullMulNonZero<P>(lhs, rhs)'
            name: fullMulNonZero_3
            args:
            - 
              SliceExpr:
                source: 'lhs'
                var: lhs
                offset: 0
                size: 3
            - 
              SliceExpr:
                source: 'rhs'
                var: rhs
                offset: 0
                size: 3
# 
# func T2 fullMulNonZero<P>(P lhs, P rhs) {
#   A = lhs[P * 0 : P]
#   B = lhs[P * 1 : P]
#   C = lhs[P * 2 : P]
#   D = rhs[P * 0 : P]
#   E = rhs[P * 1 : P]
#   F = rhs[P * 2 : P]
#   AD = fullMul<P>(A, D)
#   AE = fullMul<P>(A, E)
#   AF = fullMul<P>(A, F)
#   BD = fullMul<P>(B, D)
#   BE = fullMul<P>(B, E)
#   BF = fullMul<P>(B, F)
#   CD = fullMul<P>(C, D)
#   CE = fullMul<P>(C, E)
#   CF = fullMul<P>(C, F)
#   tryte0 = AD[P * 0 : P]
#   carry0 = AD[P * 1 : P]
#   AEBD = addProduct<P>(AE, BD)
#   AEBDc = addCarryToProduct<P>(AEBD.value, carry0, 0)
#   tryte1 = AEBDc[P * 0 : P]
#   carry1 = AEBDc[P * 1 : P]
#   AFBE = addProduct<P>(AF, BE)
#   AFBEc = addCarryToProduct<P>(AFBE.value, carry1, 0)
#   AFBEcCD = addProduct<P>(AFBEc, CD)
#   tryte2 = AFBEcCD[P * 0 : P]
#   carry2 = AFBEcCD[P * 1 : P]
#   BFCE = addProduct<P>(BF, CE)
#   BFCEc = addCarryToProduct<P>(BFCE.value, carry2, 0)
#   tryte3 = BFCEc[P * 0 : P]
#   carry3 = BFCEc[P * 1 : P]
#   CFc = addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)
#   return tryte0 & tryte1 & tryte2 & tryte3 & CFc
# }
  fullMulNonZero_3:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 6
    params:
      - 
        argName: lhs
        size: 3
        type: 
          ConstTypeName:
            typeName: P
            size: 3
      - 
        argName: rhs
        size: 3
        type: 
          ConstTypeName:
            typeName: P
            size: 3
    assigns: 
      A:
        SliceExpr:
          source: 'lhs[P * 0 : P]'
          var: lhs
          offset: 0
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 1
      B:
        SliceExpr:
          source: 'lhs[P * 1 : P]'
          var: lhs
          offset: 1
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 1
      C:
        SliceExpr:
          source: 'lhs[P * 2 : P]'
          var: lhs
          offset: 2
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 1
      D:
        SliceExpr:
          source: 'rhs[P * 0 : P]'
          var: rhs
          offset: 0
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 1
      E:
        SliceExpr:
          source: 'rhs[P * 1 : P]'
          var: rhs
          offset: 1
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 1
      F:
        SliceExpr:
          source: 'rhs[P * 2 : P]'
          var: rhs
          offset: 2
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 1
      AD:
        FuncExpr:
          source: 'fullMul<P>(A, D)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 1
      AE:
        FuncExpr:
          source: 'fullMul<P>(A, E)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 1
      AF:
        FuncExpr:
          source: 'fullMul<P>(A, F)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 1
      BD:
        FuncExpr:
          source: 'fullMul<P>(B, D)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 1
      BE:
        FuncExpr:
          source: 'fullMul<P>(B, E)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 1
      BF:
        FuncExpr:
          source: 'fullMul<P>(B, F)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 1
      CD:
        FuncExpr:
          source: 'fullMul<P>(C, D)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 1
      CE:
        FuncExpr:
          source: 'fullMul<P>(C, E)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 1
      CF:
        FuncExpr:
          source: 'fullMul<P>(C, F)'
          name: fullMul_1
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 1
      tryte0:
        SliceExpr:
          source: 'AD[P * 0 : P]'
          var: AD
          offset: 0
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 1
      carry0:
        SliceExpr:
          source: 'AD[P * 1 : P]'
          var: AD
          offset: 1
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 1
      AEBD:
        FuncExpr:
          source: 'addProduct<P>(AE, BD)'
          name: addProduct_1
          args:
          - 
            SliceExpr:
              source: 'AE'
              var: AE
              offset: 0
              size: 2
          - 
            SliceExpr:
              source: 'BD'
              var: BD
              offset: 0
              size: 2
      AEBDc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AEBD.value, carry0, 0)'
          name: addCarryToProduct_1
          args:
          - 
            SliceExpr:
              source: 'AEBD.value'
              var: AEBD
              offset: 0
              size: 2
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry0'
              var: carry0
              offset: 0
              size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte1:
        SliceExpr:
          source: 'AEBDc[P * 0 : P]'
          var: AEBDc
          offset: 0
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 1
      carry1:
        SliceExpr:
          source: 'AEBDc[P * 1 : P]'
          var: AEBDc
          offset: 1
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 1
      AFBE:
        FuncExpr:
          source: 'addProduct<P>(AF, BE)'
          name: addProduct_1
          args:
          - 
            SliceExpr:
              source: 'AF'
              var: AF
              offset: 0
              size: 2
          - 
            SliceExpr:
              source: 'BE'
              var: BE
              offset: 0
              size: 2
      AFBEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AFBE.value, carry1, 0)'
          name: addCarryToProduct_1
          args:
          - 
            SliceExpr:
              source: 'AFBE.value'
              var: AFBE
              offset: 0
              size: 2
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry1'
              var: carry1
              offset: 0
              size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      AFBEcCD:
        FuncExpr:
          source: 'addProduct<P>(AFBEc, CD)'
          name: addProduct_1
          args:
          - 
            SliceExpr:
              source: 'AFBEc'
              var: AFBEc
              offset: 0
              size: 2
          - 
            SliceExpr:
              source: 'CD'
              var: CD
              offset: 0
              size: 2
      tryte2:
        SliceExpr:
          source: 'AFBEcCD[P * 0 : P]'
          var: AFBEcCD
          offset: 0
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 1
      carry2:
        SliceExpr:
          source: 'AFBEcCD[P * 1 : P]'
          var: AFBEcCD
          offset: 1
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 1
      BFCE:
        FuncExpr:
          source: 'addProduct<P>(BF, CE)'
          name: addProduct_1
          args:
          - 
            SliceExpr:
              source: 'BF'
              var: BF
              offset: 0
              size: 2
          - 
            SliceExpr:
              source: 'CE'
              var: CE
              offset: 0
              size: 2
      BFCEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(BFCE.value, carry2, 0)'
          name: addCarryToProduct_1
          args:
          - 
            SliceExpr:
              source: 'BFCE.value'
              var: BFCE
              offset: 0
              size: 2
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry2'
              var: carry2
              offset: 0
              size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte3:
        SliceExpr:
          source: 'BFCEc[P * 0 : P]'
          var: BFCEc
          offset: 0
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 1
      carry3:
        SliceExpr:
          source: 'BFCEc[P * 1 : P]'
          var: BFCEc
          offset: 1
          size: 1
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 1
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 1
      CFc:
        FuncExpr:
          source: 'addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)'
          name: addCarryToProduct_1
          args:
          - 
            SliceExpr:
              source: 'CF'
              var: CF
              offset: 0
              size: 2
          - 
            SliceExpr:
              source: 'carry3'
              var: carry3
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'AFBEcCD.carry'
              var: AFBEcCD
              offset: 2
              size: 1
              fields: 
                - carry
    return: 
    # tryte0 & tryte1 & tryte2 & tryte3 & CFc
      ConcatExpr:
        source: 'tryte0 & tryte1 & tryte2 & tryte3 & CFc'
        lhs: 
          ConcatExpr:
            source: 'tryte0 & tryte1 & tryte2 & tryte3'
            lhs: 
              ConcatExpr:
                source: 'tryte0 & tryte1 & tryte2'
                lhs: 
                  ConcatExpr:
                    source: 'tryte0 & tryte1'
                    lhs: 
                      SliceExpr:
                        source: 'tryte0'
                        var: tryte0
                        offset: 0
                        size: 1
                    rhs: 
                      SliceExpr:
                        source: 'tryte1'
                        var: tryte1
                        offset: 0
                        size: 1
                rhs: 
                  SliceExpr:
                    source: 'tryte2'
                    var: tryte2
                    offset: 0
                    size: 1
            rhs: 
              SliceExpr:
                source: 'tryte3'
                var: tryte3
                offset: 0
                size: 1
        rhs: 
          SliceExpr:
            source: 'CFc'
            var: CFc
            offset: 0
            size: 2
# 
# func P2Carry addProduct<P>(P2 lhs, P2 rhs) {
#   lo = fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)
#   hi = fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)
#   return lo.value & hi
# }
  addProduct_1:
    returnType: 
      ConstTypeName:
        typeName: P2Carry
        size: 3
        fields:
          value: 
            size: '2'
            offset: '0'
          carry: 
            size: '1'
            offset: '2'
    params:
      - 
        argName: lhs
        size: 2
        type: 
          ConstTypeName:
            typeName: P2
            size: 2
      - 
        argName: rhs
        size: 2
        type: 
          ConstTypeName:
            typeName: P2
            size: 2
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)'
          name: fullAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 1
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 1
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[P * 0 : P]'
              var: rhs
              offset: 0
              size: 1
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 1
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      hi:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)'
          name: fullAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 1
              size: 1
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 1
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[P * 1 : P]'
              var: rhs
              offset: 1
              size: 1
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 1
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 1
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 1
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi
      ConcatExpr:
        source: 'lo.value & hi'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 1
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi'
            var: hi
            offset: 0
            size: 2
# 
# func P2 addCarryToProduct<P>(P2 lhs, P carry, Carry extraTrit) {
#   lo = fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)
#   hi = halfAdd<P>(lhs[P * 1 : P], lo.carry)
#   return lo.value & hi.value
# }
  addCarryToProduct_1:
    returnType: 
      ConstTypeName:
        typeName: P2
        size: 2
    params:
      - 
        argName: lhs
        size: 2
        type: 
          ConstTypeName:
            typeName: P2
            size: 2
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: P
            size: 1
      - 
        argName: extraTrit
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)'
          name: fullAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 1
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 1
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 1
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'extraTrit'
              var: extraTrit
              offset: 0
              size: 1
      hi:
        FuncExpr:
          source: 'halfAdd<P>(lhs[P * 1 : P], lo.carry)'
          name: halfAdd_1
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 1
              size: 1
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 1
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 1
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 1
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi.value
      ConcatExpr:
        source: 'lo.value & hi.value'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 1
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi.value'
            var: hi
            offset: 0
            size: 1
            fields: 
              - value
# 
# func TCarry halfAdd<P>(P val, Carry carry) {
#   add0 = halfAdd<A>(val[0 : A], carry)
#   add1 = halfAdd<B>(val[A : B], add0.carry)
#   add2 = halfAdd<C>(val[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  halfAdd_3:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 4
        fields:
          value: 
            size: '3'
            offset: '0'
          carry: 
            size: '1'
            offset: '3'
    params:
      - 
        argName: val
        size: 3
        type: 
          ConstTypeName:
            typeName: P
            size: 3
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'halfAdd<A>(val[0 : A], carry)'
          name: halfAdd_1
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'halfAdd<B>(val[A : B], add0.carry)'
          name: halfAdd_1
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 1
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'halfAdd<C>(val[A + B : C], add1.carry)'
          name: halfAdd_1
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 1
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 1
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 1
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 2
# 
# func Tiny decr<Tiny>(Tiny val) {
#   halfSum = halfAdd<Tiny>(val, -)
#   return halfSum.value
# }
  decr_9:
    returnType: 
      ConstTypeName:
        typeName: Tiny
        size: 9
    params:
      - 
        argName: val
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
    assigns: 
      halfSum:
        FuncExpr:
          source: 'halfAdd<Tiny>(val, -)'
          name: halfAdd_9
          args:
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 9
          - 
            ValueExpr:
                value: '-'
                trits: '-'
                trytes: 'Z'
    return: 
    # halfSum.value
      SliceExpr:
        source: 'halfSum.value'
        var: halfSum
        offset: 0
        size: 9
        fields: 
          - value
# 
# func TCarry halfAdd<Tiny>(Tiny val, Carry carry) {
#   add0 = halfAdd<A>(val[0 : A], carry)
#   add1 = halfAdd<B>(val[A : B], add0.carry)
#   add2 = halfAdd<C>(val[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  halfAdd_9:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 10
        fields:
          value: 
            size: '9'
            offset: '0'
          carry: 
            size: '1'
            offset: '9'
    params:
      - 
        argName: val
        size: 9
        type: 
          ConstTypeName:
            typeName: Tiny
            size: 9
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'halfAdd<A>(val[0 : A], carry)'
          name: halfAdd_3
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'halfAdd<B>(val[A : B], add0.carry)'
          name: halfAdd_3
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 3
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'halfAdd<C>(val[A + B : C], add1.carry)'
          name: halfAdd_3
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 3
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 3
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 3
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 4
# 
# func Huge factorial<Huge>(Huge n) {
#   isZero = isZero[sign<Huge>(n)]
#   return isZero ? 1 : mul<Huge>(n, factorial<Huge>(decr<Huge>(n)))
# }
  factorial_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      isZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(n)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
    return: 
    # isZero ? 1 : mul<Huge>(n, factorial<Huge>(decr<Huge>(n)))
      CondExpr:
        source: 'isZero ? 1 : mul<Huge>(n, factorial<Huge>(decr<Huge>(n)))'
        if: 
          SliceExpr:
            source: 'isZero'
            var: isZero
            offset: 0
            size: 1
        then: 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'A99999999999999999999999999'
        else:
          FuncExpr:
            source: 'mul<Huge>(n, factorial<Huge>(decr<Huge>(n)))'
            name: mul_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              FuncExpr:
                source: 'factorial<Huge>(decr<Huge>(n))'
                name: factorial_81
                args:
                - 
                  FuncExpr:
                    source: 'decr<Huge>(n)'
                    name: decr_81
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 81
# 
# func Huge mul<Huge>(Huge lhs, Huge rhs) {
#   lhsZero = isZero[sign<Huge>(lhs)]
#   rhsZero = isZero[sign<Huge>(rhs)]
#   product = fullMulNonZero<Huge>(lhs, rhs)
#   return or[lhsZero, rhsZero] ? 0 : product[0 : Huge]
# }
  mul_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(lhs)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 81
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(rhs)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 81
      product:
        FuncExpr:
          source: 'fullMulNonZero<Huge>(lhs, rhs)'
          name: fullMulNonZero_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
    return: 
    # or[lhsZero, rhsZero] ? 0 : product[0 : Huge]
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : product[0 : Huge]'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999'
        else:
          SliceExpr:
            source: 'product[0 : Huge]'
            var: product
            offset: 0
            size: 81
            start:
              ConstNumber:
                value: 0
            end:
              ConstTypeName:
                typeName: Huge
                size: 81
# 
# func T2 fullMul<Huge>(Huge lhs, Huge rhs) {
#   lhsZero = isZero[sign<Huge>(lhs)]
#   rhsZero = isZero[sign<Huge>(rhs)]
#   return or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Huge>(lhs, rhs)
# }
  fullMul_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(lhs)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 81
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(rhs)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 81
    return: 
    # or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Huge>(lhs, rhs)
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Huge>(lhs, rhs)'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999999999999999999999999999999'
        else:
          FuncExpr:
            source: 'fullMulNonZero<Huge>(lhs, rhs)'
            name: fullMulNonZero_81
            args:
            - 
              SliceExpr:
                source: 'lhs'
                var: lhs
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'rhs'
                var: rhs
                offset: 0
                size: 81
# 
# func T2 fullMulNonZero<Huge>(Huge lhs, Huge rhs) {
#   A = lhs[P * 0 : P]
#   B = lhs[P * 1 : P]
#   C = lhs[P * 2 : P]
#   D = rhs[P * 0 : P]
#   E = rhs[P * 1 : P]
#   F = rhs[P * 2 : P]
#   AD = fullMul<P>(A, D)
#   AE = fullMul<P>(A, E)
#   AF = fullMul<P>(A, F)
#   BD = fullMul<P>(B, D)
#   BE = fullMul<P>(B, E)
#   BF = fullMul<P>(B, F)
#   CD = fullMul<P>(C, D)
#   CE = fullMul<P>(C, E)
#   CF = fullMul<P>(C, F)
#   tryte0 = AD[P * 0 : P]
#   carry0 = AD[P * 1 : P]
#   AEBD = addProduct<P>(AE, BD)
#   AEBDc = addCarryToProduct<P>(AEBD.value, carry0, 0)
#   tryte1 = AEBDc[P * 0 : P]
#   carry1 = AEBDc[P * 1 : P]
#   AFBE = addProduct<P>(AF, BE)
#   AFBEc = addCarryToProduct<P>(AFBE.value, carry1, 0)
#   AFBEcCD = addProduct<P>(AFBEc, CD)
#   tryte2 = AFBEcCD[P * 0 : P]
#   carry2 = AFBEcCD[P * 1 : P]
#   BFCE = addProduct<P>(BF, CE)
#   BFCEc = addCarryToProduct<P>(BFCE.value, carry2, 0)
#   tryte3 = BFCEc[P * 0 : P]
#   carry3 = BFCEc[P * 1 : P]
#   CFc = addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)
#   return tryte0 & tryte1 & tryte2 & tryte3 & CFc
# }
  fullMulNonZero_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      A:
        SliceExpr:
          source: 'lhs[P * 0 : P]'
          var: lhs
          offset: 0
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 27
      B:
        SliceExpr:
          source: 'lhs[P * 1 : P]'
          var: lhs
          offset: 27
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 27
      C:
        SliceExpr:
          source: 'lhs[P * 2 : P]'
          var: lhs
          offset: 54
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 27
      D:
        SliceExpr:
          source: 'rhs[P * 0 : P]'
          var: rhs
          offset: 0
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 27
      E:
        SliceExpr:
          source: 'rhs[P * 1 : P]'
          var: rhs
          offset: 27
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 27
      F:
        SliceExpr:
          source: 'rhs[P * 2 : P]'
          var: rhs
          offset: 54
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 27
      AD:
        FuncExpr:
          source: 'fullMul<P>(A, D)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 27
      AE:
        FuncExpr:
          source: 'fullMul<P>(A, E)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 27
      AF:
        FuncExpr:
          source: 'fullMul<P>(A, F)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 27
      BD:
        FuncExpr:
          source: 'fullMul<P>(B, D)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 27
      BE:
        FuncExpr:
          source: 'fullMul<P>(B, E)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 27
      BF:
        FuncExpr:
          source: 'fullMul<P>(B, F)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 27
      CD:
        FuncExpr:
          source: 'fullMul<P>(C, D)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 27
      CE:
        FuncExpr:
          source: 'fullMul<P>(C, E)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 27
      CF:
        FuncExpr:
          source: 'fullMul<P>(C, F)'
          name: fullMul_27
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 27
      tryte0:
        SliceExpr:
          source: 'AD[P * 0 : P]'
          var: AD
          offset: 0
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 27
      carry0:
        SliceExpr:
          source: 'AD[P * 1 : P]'
          var: AD
          offset: 27
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 27
      AEBD:
        FuncExpr:
          source: 'addProduct<P>(AE, BD)'
          name: addProduct_27
          args:
          - 
            SliceExpr:
              source: 'AE'
              var: AE
              offset: 0
              size: 54
          - 
            SliceExpr:
              source: 'BD'
              var: BD
              offset: 0
              size: 54
      AEBDc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AEBD.value, carry0, 0)'
          name: addCarryToProduct_27
          args:
          - 
            SliceExpr:
              source: 'AEBD.value'
              var: AEBD
              offset: 0
              size: 54
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry0'
              var: carry0
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte1:
        SliceExpr:
          source: 'AEBDc[P * 0 : P]'
          var: AEBDc
          offset: 0
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 27
      carry1:
        SliceExpr:
          source: 'AEBDc[P * 1 : P]'
          var: AEBDc
          offset: 27
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 27
      AFBE:
        FuncExpr:
          source: 'addProduct<P>(AF, BE)'
          name: addProduct_27
          args:
          - 
            SliceExpr:
              source: 'AF'
              var: AF
              offset: 0
              size: 54
          - 
            SliceExpr:
              source: 'BE'
              var: BE
              offset: 0
              size: 54
      AFBEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AFBE.value, carry1, 0)'
          name: addCarryToProduct_27
          args:
          - 
            SliceExpr:
              source: 'AFBE.value'
              var: AFBE
              offset: 0
              size: 54
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry1'
              var: carry1
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      AFBEcCD:
        FuncExpr:
          source: 'addProduct<P>(AFBEc, CD)'
          name: addProduct_27
          args:
          - 
            SliceExpr:
              source: 'AFBEc'
              var: AFBEc
              offset: 0
              size: 54
          - 
            SliceExpr:
              source: 'CD'
              var: CD
              offset: 0
              size: 54
      tryte2:
        SliceExpr:
          source: 'AFBEcCD[P * 0 : P]'
          var: AFBEcCD
          offset: 0
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 27
      carry2:
        SliceExpr:
          source: 'AFBEcCD[P * 1 : P]'
          var: AFBEcCD
          offset: 27
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 27
      BFCE:
        FuncExpr:
          source: 'addProduct<P>(BF, CE)'
          name: addProduct_27
          args:
          - 
            SliceExpr:
              source: 'BF'
              var: BF
              offset: 0
              size: 54
          - 
            SliceExpr:
              source: 'CE'
              var: CE
              offset: 0
              size: 54
      BFCEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(BFCE.value, carry2, 0)'
          name: addCarryToProduct_27
          args:
          - 
            SliceExpr:
              source: 'BFCE.value'
              var: BFCE
              offset: 0
              size: 54
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry2'
              var: carry2
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte3:
        SliceExpr:
          source: 'BFCEc[P * 0 : P]'
          var: BFCEc
          offset: 0
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 27
      carry3:
        SliceExpr:
          source: 'BFCEc[P * 1 : P]'
          var: BFCEc
          offset: 27
          size: 27
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 27
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 27
      CFc:
        FuncExpr:
          source: 'addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)'
          name: addCarryToProduct_27
          args:
          - 
            SliceExpr:
              source: 'CF'
              var: CF
              offset: 0
              size: 54
          - 
            SliceExpr:
              source: 'carry3'
              var: carry3
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'AFBEcCD.carry'
              var: AFBEcCD
              offset: 54
              size: 1
              fields: 
                - carry
    return: 
    # tryte0 & tryte1 & tryte2 & tryte3 & CFc
      ConcatExpr:
        source: 'tryte0 & tryte1 & tryte2 & tryte3 & CFc'
        lhs: 
          ConcatExpr:
            source: 'tryte0 & tryte1 & tryte2 & tryte3'
            lhs: 
              ConcatExpr:
                source: 'tryte0 & tryte1 & tryte2'
                lhs: 
                  ConcatExpr:
                    source: 'tryte0 & tryte1'
                    lhs: 
                      SliceExpr:
                        source: 'tryte0'
                        var: tryte0
                        offset: 0
                        size: 27
                    rhs: 
                      SliceExpr:
                        source: 'tryte1'
                        var: tryte1
                        offset: 0
                        size: 27
                rhs: 
                  SliceExpr:
                    source: 'tryte2'
                    var: tryte2
                    offset: 0
                    size: 27
            rhs: 
              SliceExpr:
                source: 'tryte3'
                var: tryte3
                offset: 0
                size: 27
        rhs: 
          SliceExpr:
            source: 'CFc'
            var: CFc
            offset: 0
            size: 54
# 
# func P2Carry addProduct<P>(P2 lhs, P2 rhs) {
#   lo = fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)
#   hi = fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)
#   return lo.value & hi
# }
  addProduct_27:
    returnType: 
      ConstTypeName:
        typeName: P2Carry
        size: 55
        fields:
          value: 
            size: '54'
            offset: '0'
          carry: 
            size: '1'
            offset: '54'
    params:
      - 
        argName: lhs
        size: 54
        type: 
          ConstTypeName:
            typeName: P2
            size: 54
      - 
        argName: rhs
        size: 54
        type: 
          ConstTypeName:
            typeName: P2
            size: 54
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 27
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 27
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[P * 0 : P]'
              var: rhs
              offset: 0
              size: 27
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 27
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      hi:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 27
              size: 27
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 27
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[P * 1 : P]'
              var: rhs
              offset: 27
              size: 27
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 27
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 27
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 27
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi
      ConcatExpr:
        source: 'lo.value & hi'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 27
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi'
            var: hi
            offset: 0
            size: 28
# 
# func P2 addCarryToProduct<P>(P2 lhs, P carry, Carry extraTrit) {
#   lo = fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)
#   hi = halfAdd<P>(lhs[P * 1 : P], lo.carry)
#   return lo.value & hi.value
# }
  addCarryToProduct_27:
    returnType: 
      ConstTypeName:
        typeName: P2
        size: 54
    params:
      - 
        argName: lhs
        size: 54
        type: 
          ConstTypeName:
            typeName: P2
            size: 54
      - 
        argName: carry
        size: 27
        type: 
          ConstTypeName:
            typeName: P
            size: 27
      - 
        argName: extraTrit
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 27
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 27
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 27
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'extraTrit'
              var: extraTrit
              offset: 0
              size: 1
      hi:
        FuncExpr:
          source: 'halfAdd<P>(lhs[P * 1 : P], lo.carry)'
          name: halfAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 27
              size: 27
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 27
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 27
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 27
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi.value
      ConcatExpr:
        source: 'lo.value & hi.value'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 27
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi.value'
            var: hi
            offset: 0
            size: 27
            fields: 
              - value
# 
# func T2 fullMul<P>(P lhs, P rhs) {
#   lhsZero = isZero[sign<P>(lhs)]
#   rhsZero = isZero[sign<P>(rhs)]
#   return or[lhsZero, rhsZero] ? 0 : fullMulNonZero<P>(lhs, rhs)
# }
  fullMul_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: P
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: P
            size: 27
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<P>(lhs)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 27
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<P>(rhs)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 27
    return: 
    # or[lhsZero, rhsZero] ? 0 : fullMulNonZero<P>(lhs, rhs)
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : fullMulNonZero<P>(lhs, rhs)'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999'
        else:
          FuncExpr:
            source: 'fullMulNonZero<P>(lhs, rhs)'
            name: fullMulNonZero_27
            args:
            - 
              SliceExpr:
                source: 'lhs'
                var: lhs
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'rhs'
                var: rhs
                offset: 0
                size: 27
# 
# func T2 fullMulNonZero<P>(P lhs, P rhs) {
#   A = lhs[P * 0 : P]
#   B = lhs[P * 1 : P]
#   C = lhs[P * 2 : P]
#   D = rhs[P * 0 : P]
#   E = rhs[P * 1 : P]
#   F = rhs[P * 2 : P]
#   AD = fullMul<P>(A, D)
#   AE = fullMul<P>(A, E)
#   AF = fullMul<P>(A, F)
#   BD = fullMul<P>(B, D)
#   BE = fullMul<P>(B, E)
#   BF = fullMul<P>(B, F)
#   CD = fullMul<P>(C, D)
#   CE = fullMul<P>(C, E)
#   CF = fullMul<P>(C, F)
#   tryte0 = AD[P * 0 : P]
#   carry0 = AD[P * 1 : P]
#   AEBD = addProduct<P>(AE, BD)
#   AEBDc = addCarryToProduct<P>(AEBD.value, carry0, 0)
#   tryte1 = AEBDc[P * 0 : P]
#   carry1 = AEBDc[P * 1 : P]
#   AFBE = addProduct<P>(AF, BE)
#   AFBEc = addCarryToProduct<P>(AFBE.value, carry1, 0)
#   AFBEcCD = addProduct<P>(AFBEc, CD)
#   tryte2 = AFBEcCD[P * 0 : P]
#   carry2 = AFBEcCD[P * 1 : P]
#   BFCE = addProduct<P>(BF, CE)
#   BFCEc = addCarryToProduct<P>(BFCE.value, carry2, 0)
#   tryte3 = BFCEc[P * 0 : P]
#   carry3 = BFCEc[P * 1 : P]
#   CFc = addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)
#   return tryte0 & tryte1 & tryte2 & tryte3 & CFc
# }
  fullMulNonZero_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: P
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: P
            size: 27
    assigns: 
      A:
        SliceExpr:
          source: 'lhs[P * 0 : P]'
          var: lhs
          offset: 0
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 9
      B:
        SliceExpr:
          source: 'lhs[P * 1 : P]'
          var: lhs
          offset: 9
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 9
      C:
        SliceExpr:
          source: 'lhs[P * 2 : P]'
          var: lhs
          offset: 18
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 9
      D:
        SliceExpr:
          source: 'rhs[P * 0 : P]'
          var: rhs
          offset: 0
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 9
      E:
        SliceExpr:
          source: 'rhs[P * 1 : P]'
          var: rhs
          offset: 9
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 9
      F:
        SliceExpr:
          source: 'rhs[P * 2 : P]'
          var: rhs
          offset: 18
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 9
      AD:
        FuncExpr:
          source: 'fullMul<P>(A, D)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 9
      AE:
        FuncExpr:
          source: 'fullMul<P>(A, E)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 9
      AF:
        FuncExpr:
          source: 'fullMul<P>(A, F)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 9
      BD:
        FuncExpr:
          source: 'fullMul<P>(B, D)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 9
      BE:
        FuncExpr:
          source: 'fullMul<P>(B, E)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 9
      BF:
        FuncExpr:
          source: 'fullMul<P>(B, F)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 9
      CD:
        FuncExpr:
          source: 'fullMul<P>(C, D)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 9
      CE:
        FuncExpr:
          source: 'fullMul<P>(C, E)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 9
      CF:
        FuncExpr:
          source: 'fullMul<P>(C, F)'
          name: fullMul_9
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 9
      tryte0:
        SliceExpr:
          source: 'AD[P * 0 : P]'
          var: AD
          offset: 0
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 9
      carry0:
        SliceExpr:
          source: 'AD[P * 1 : P]'
          var: AD
          offset: 9
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 9
      AEBD:
        FuncExpr:
          source: 'addProduct<P>(AE, BD)'
          name: addProduct_9
          args:
          - 
            SliceExpr:
              source: 'AE'
              var: AE
              offset: 0
              size: 18
          - 
            SliceExpr:
              source: 'BD'
              var: BD
              offset: 0
              size: 18
      AEBDc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AEBD.value, carry0, 0)'
          name: addCarryToProduct_9
          args:
          - 
            SliceExpr:
              source: 'AEBD.value'
              var: AEBD
              offset: 0
              size: 18
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry0'
              var: carry0
              offset: 0
              size: 9
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte1:
        SliceExpr:
          source: 'AEBDc[P * 0 : P]'
          var: AEBDc
          offset: 0
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 9
      carry1:
        SliceExpr:
          source: 'AEBDc[P * 1 : P]'
          var: AEBDc
          offset: 9
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 9
      AFBE:
        FuncExpr:
          source: 'addProduct<P>(AF, BE)'
          name: addProduct_9
          args:
          - 
            SliceExpr:
              source: 'AF'
              var: AF
              offset: 0
              size: 18
          - 
            SliceExpr:
              source: 'BE'
              var: BE
              offset: 0
              size: 18
      AFBEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AFBE.value, carry1, 0)'
          name: addCarryToProduct_9
          args:
          - 
            SliceExpr:
              source: 'AFBE.value'
              var: AFBE
              offset: 0
              size: 18
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry1'
              var: carry1
              offset: 0
              size: 9
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      AFBEcCD:
        FuncExpr:
          source: 'addProduct<P>(AFBEc, CD)'
          name: addProduct_9
          args:
          - 
            SliceExpr:
              source: 'AFBEc'
              var: AFBEc
              offset: 0
              size: 18
          - 
            SliceExpr:
              source: 'CD'
              var: CD
              offset: 0
              size: 18
      tryte2:
        SliceExpr:
          source: 'AFBEcCD[P * 0 : P]'
          var: AFBEcCD
          offset: 0
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 9
      carry2:
        SliceExpr:
          source: 'AFBEcCD[P * 1 : P]'
          var: AFBEcCD
          offset: 9
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 9
      BFCE:
        FuncExpr:
          source: 'addProduct<P>(BF, CE)'
          name: addProduct_9
          args:
          - 
            SliceExpr:
              source: 'BF'
              var: BF
              offset: 0
              size: 18
          - 
            SliceExpr:
              source: 'CE'
              var: CE
              offset: 0
              size: 18
      BFCEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(BFCE.value, carry2, 0)'
          name: addCarryToProduct_9
          args:
          - 
            SliceExpr:
              source: 'BFCE.value'
              var: BFCE
              offset: 0
              size: 18
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry2'
              var: carry2
              offset: 0
              size: 9
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte3:
        SliceExpr:
          source: 'BFCEc[P * 0 : P]'
          var: BFCEc
          offset: 0
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 9
      carry3:
        SliceExpr:
          source: 'BFCEc[P * 1 : P]'
          var: BFCEc
          offset: 9
          size: 9
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 9
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 9
      CFc:
        FuncExpr:
          source: 'addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)'
          name: addCarryToProduct_9
          args:
          - 
            SliceExpr:
              source: 'CF'
              var: CF
              offset: 0
              size: 18
          - 
            SliceExpr:
              source: 'carry3'
              var: carry3
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'AFBEcCD.carry'
              var: AFBEcCD
              offset: 18
              size: 1
              fields: 
                - carry
    return: 
    # tryte0 & tryte1 & tryte2 & tryte3 & CFc
      ConcatExpr:
        source: 'tryte0 & tryte1 & tryte2 & tryte3 & CFc'
        lhs: 
          ConcatExpr:
            source: 'tryte0 & tryte1 & tryte2 & tryte3'
            lhs: 
              ConcatExpr:
                source: 'tryte0 & tryte1 & tryte2'
                lhs: 
                  ConcatExpr:
                    source: 'tryte0 & tryte1'
                    lhs: 
                      SliceExpr:
                        source: 'tryte0'
                        var: tryte0
                        offset: 0
                        size: 9
                    rhs: 
                      SliceExpr:
                        source: 'tryte1'
                        var: tryte1
                        offset: 0
                        size: 9
                rhs: 
                  SliceExpr:
                    source: 'tryte2'
                    var: tryte2
                    offset: 0
                    size: 9
            rhs: 
              SliceExpr:
                source: 'tryte3'
                var: tryte3
                offset: 0
                size: 9
        rhs: 
          SliceExpr:
            source: 'CFc'
            var: CFc
            offset: 0
            size: 18
# 
# func P2Carry addProduct<P>(P2 lhs, P2 rhs) {
#   lo = fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)
#   hi = fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)
#   return lo.value & hi
# }
  addProduct_9:
    returnType: 
      ConstTypeName:
        typeName: P2Carry
        size: 19
        fields:
          value: 
            size: '18'
            offset: '0'
          carry: 
            size: '1'
            offset: '18'
    params:
      - 
        argName: lhs
        size: 18
        type: 
          ConstTypeName:
            typeName: P2
            size: 18
      - 
        argName: rhs
        size: 18
        type: 
          ConstTypeName:
            typeName: P2
            size: 18
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)'
          name: fullAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 9
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 9
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[P * 0 : P]'
              var: rhs
              offset: 0
              size: 9
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 9
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 9
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      hi:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)'
          name: fullAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 9
              size: 9
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 9
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[P * 1 : P]'
              var: rhs
              offset: 9
              size: 9
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 9
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 9
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 9
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi
      ConcatExpr:
        source: 'lo.value & hi'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 9
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi'
            var: hi
            offset: 0
            size: 10
# 
# func P2 addCarryToProduct<P>(P2 lhs, P carry, Carry extraTrit) {
#   lo = fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)
#   hi = halfAdd<P>(lhs[P * 1 : P], lo.carry)
#   return lo.value & hi.value
# }
  addCarryToProduct_9:
    returnType: 
      ConstTypeName:
        typeName: P2
        size: 18
    params:
      - 
        argName: lhs
        size: 18
        type: 
          ConstTypeName:
            typeName: P2
            size: 18
      - 
        argName: carry
        size: 9
        type: 
          ConstTypeName:
            typeName: P
            size: 9
      - 
        argName: extraTrit
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)'
          name: fullAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 9
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 9
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 9
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 9
          - 
            SliceExpr:
              source: 'extraTrit'
              var: extraTrit
              offset: 0
              size: 1
      hi:
        FuncExpr:
          source: 'halfAdd<P>(lhs[P * 1 : P], lo.carry)'
          name: halfAdd_9
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 9
              size: 9
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 9
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 9
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 9
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi.value
      ConcatExpr:
        source: 'lo.value & hi.value'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 9
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi.value'
            var: hi
            offset: 0
            size: 9
            fields: 
              - value
# 
# func TCarry halfAdd<P>(P val, Carry carry) {
#   add0 = halfAdd<A>(val[0 : A], carry)
#   add1 = halfAdd<B>(val[A : B], add0.carry)
#   add2 = halfAdd<C>(val[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  halfAdd_27:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 28
        fields:
          value: 
            size: '27'
            offset: '0'
          carry: 
            size: '1'
            offset: '27'
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: P
            size: 27
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'halfAdd<A>(val[0 : A], carry)'
          name: halfAdd_9
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'halfAdd<B>(val[A : B], add0.carry)'
          name: halfAdd_9
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 9
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'halfAdd<C>(val[A + B : C], add1.carry)'
          name: halfAdd_9
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 9
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 9
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 9
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 10
# 
# func Huge decr<Huge>(Huge val) {
#   halfSum = halfAdd<Huge>(val, -)
#   return halfSum.value
# }
  decr_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      halfSum:
        FuncExpr:
          source: 'halfAdd<Huge>(val, -)'
          name: halfAdd_81
          args:
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '-'
                trits: '-'
                trytes: 'Z'
    return: 
    # halfSum.value
      SliceExpr:
        source: 'halfSum.value'
        var: halfSum
        offset: 0
        size: 81
        fields: 
          - value
# 
# func TCarry halfAdd<Huge>(Huge val, Carry carry) {
#   add0 = halfAdd<A>(val[0 : A], carry)
#   add1 = halfAdd<B>(val[A : B], add0.carry)
#   add2 = halfAdd<C>(val[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  halfAdd_81:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 82
        fields:
          value: 
            size: '81'
            offset: '0'
          carry: 
            size: '1'
            offset: '81'
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'halfAdd<A>(val[0 : A], carry)'
          name: halfAdd_27
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'halfAdd<B>(val[A : B], add0.carry)'
          name: halfAdd_27
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 27
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'halfAdd<C>(val[A + B : C], add1.carry)'
          name: halfAdd_27
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 27
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 27
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 27
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 28
# 
# func Hash factorial<Hash>(Hash n) {
#   isZero = isZero[sign<Hash>(n)]
#   return isZero ? 1 : mul<Hash>(n, factorial<Hash>(decr<Hash>(n)))
# }
  factorial_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: n
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      isZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash>(n)'
                name: sign_243
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 243
    return: 
    # isZero ? 1 : mul<Hash>(n, factorial<Hash>(decr<Hash>(n)))
      CondExpr:
        source: 'isZero ? 1 : mul<Hash>(n, factorial<Hash>(decr<Hash>(n)))'
        if: 
          SliceExpr:
            source: 'isZero'
            var: isZero
            offset: 0
            size: 1
        then: 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'A99999999999999999999999999999999999999999999999999999999999999999999999999999999'
        else:
          FuncExpr:
            source: 'mul<Hash>(n, factorial<Hash>(decr<Hash>(n)))'
            name: mul_243
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 243
            - 
              FuncExpr:
                source: 'factorial<Hash>(decr<Hash>(n))'
                name: factorial_243
                args:
                - 
                  FuncExpr:
                    source: 'decr<Hash>(n)'
                    name: decr_243
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 243
# 
# func Hash mul<Hash>(Hash lhs, Hash rhs) {
#   lhsZero = isZero[sign<Hash>(lhs)]
#   rhsZero = isZero[sign<Hash>(rhs)]
#   product = fullMulNonZero<Hash>(lhs, rhs)
#   return or[lhsZero, rhsZero] ? 0 : product[0 : Hash]
# }
  mul_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: lhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: rhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash>(lhs)'
                name: sign_243
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 243
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash>(rhs)'
                name: sign_243
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 243
      product:
        FuncExpr:
          source: 'fullMulNonZero<Hash>(lhs, rhs)'
          name: fullMulNonZero_243
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 243
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 243
    return: 
    # or[lhsZero, rhsZero] ? 0 : product[0 : Hash]
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : product[0 : Hash]'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999999999999999999999999999999999999999999999999999999999'
        else:
          SliceExpr:
            source: 'product[0 : Hash]'
            var: product
            offset: 0
            size: 243
            start:
              ConstNumber:
                value: 0
            end:
              ConstTypeName:
                typeName: Hash
                size: 243
# 
# func T2 fullMul<Hash>(Hash lhs, Hash rhs) {
#   lhsZero = isZero[sign<Hash>(lhs)]
#   rhsZero = isZero[sign<Hash>(rhs)]
#   return or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Hash>(lhs, rhs)
# }
  fullMul_243:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 486
    params:
      - 
        argName: lhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: rhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash>(lhs)'
                name: sign_243
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 243
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Hash>(rhs)'
                name: sign_243
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 243
    return: 
    # or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Hash>(lhs, rhs)
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : fullMulNonZero<Hash>(lhs, rhs)'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
        else:
          FuncExpr:
            source: 'fullMulNonZero<Hash>(lhs, rhs)'
            name: fullMulNonZero_243
            args:
            - 
              SliceExpr:
                source: 'lhs'
                var: lhs
                offset: 0
                size: 243
            - 
              SliceExpr:
                source: 'rhs'
                var: rhs
                offset: 0
                size: 243
# 
# func T2 fullMulNonZero<Hash>(Hash lhs, Hash rhs) {
#   A = lhs[P * 0 : P]
#   B = lhs[P * 1 : P]
#   C = lhs[P * 2 : P]
#   D = rhs[P * 0 : P]
#   E = rhs[P * 1 : P]
#   F = rhs[P * 2 : P]
#   AD = fullMul<P>(A, D)
#   AE = fullMul<P>(A, E)
#   AF = fullMul<P>(A, F)
#   BD = fullMul<P>(B, D)
#   BE = fullMul<P>(B, E)
#   BF = fullMul<P>(B, F)
#   CD = fullMul<P>(C, D)
#   CE = fullMul<P>(C, E)
#   CF = fullMul<P>(C, F)
#   tryte0 = AD[P * 0 : P]
#   carry0 = AD[P * 1 : P]
#   AEBD = addProduct<P>(AE, BD)
#   AEBDc = addCarryToProduct<P>(AEBD.value, carry0, 0)
#   tryte1 = AEBDc[P * 0 : P]
#   carry1 = AEBDc[P * 1 : P]
#   AFBE = addProduct<P>(AF, BE)
#   AFBEc = addCarryToProduct<P>(AFBE.value, carry1, 0)
#   AFBEcCD = addProduct<P>(AFBEc, CD)
#   tryte2 = AFBEcCD[P * 0 : P]
#   carry2 = AFBEcCD[P * 1 : P]
#   BFCE = addProduct<P>(BF, CE)
#   BFCEc = addCarryToProduct<P>(BFCE.value, carry2, 0)
#   tryte3 = BFCEc[P * 0 : P]
#   carry3 = BFCEc[P * 1 : P]
#   CFc = addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)
#   return tryte0 & tryte1 & tryte2 & tryte3 & CFc
# }
  fullMulNonZero_243:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 486
    params:
      - 
        argName: lhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: rhs
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      A:
        SliceExpr:
          source: 'lhs[P * 0 : P]'
          var: lhs
          offset: 0
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 81
      B:
        SliceExpr:
          source: 'lhs[P * 1 : P]'
          var: lhs
          offset: 81
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 81
      C:
        SliceExpr:
          source: 'lhs[P * 2 : P]'
          var: lhs
          offset: 162
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 81
      D:
        SliceExpr:
          source: 'rhs[P * 0 : P]'
          var: rhs
          offset: 0
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 81
      E:
        SliceExpr:
          source: 'rhs[P * 1 : P]'
          var: rhs
          offset: 81
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 81
      F:
        SliceExpr:
          source: 'rhs[P * 2 : P]'
          var: rhs
          offset: 162
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 2
          end:
            ConstTypeName:
              typeName: P
              size: 81
      AD:
        FuncExpr:
          source: 'fullMul<P>(A, D)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 81
      AE:
        FuncExpr:
          source: 'fullMul<P>(A, E)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 81
      AF:
        FuncExpr:
          source: 'fullMul<P>(A, F)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'A'
              var: A
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 81
      BD:
        FuncExpr:
          source: 'fullMul<P>(B, D)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 81
      BE:
        FuncExpr:
          source: 'fullMul<P>(B, E)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 81
      BF:
        FuncExpr:
          source: 'fullMul<P>(B, F)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'B'
              var: B
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 81
      CD:
        FuncExpr:
          source: 'fullMul<P>(C, D)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'D'
              var: D
              offset: 0
              size: 81
      CE:
        FuncExpr:
          source: 'fullMul<P>(C, E)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'E'
              var: E
              offset: 0
              size: 81
      CF:
        FuncExpr:
          source: 'fullMul<P>(C, F)'
          name: fullMul_81
          args:
          - 
            SliceExpr:
              source: 'C'
              var: C
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'F'
              var: F
              offset: 0
              size: 81
      tryte0:
        SliceExpr:
          source: 'AD[P * 0 : P]'
          var: AD
          offset: 0
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 81
      carry0:
        SliceExpr:
          source: 'AD[P * 1 : P]'
          var: AD
          offset: 81
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 81
      AEBD:
        FuncExpr:
          source: 'addProduct<P>(AE, BD)'
          name: addProduct_81
          args:
          - 
            SliceExpr:
              source: 'AE'
              var: AE
              offset: 0
              size: 162
          - 
            SliceExpr:
              source: 'BD'
              var: BD
              offset: 0
              size: 162
      AEBDc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AEBD.value, carry0, 0)'
          name: addCarryToProduct_81
          args:
          - 
            SliceExpr:
              source: 'AEBD.value'
              var: AEBD
              offset: 0
              size: 162
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry0'
              var: carry0
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte1:
        SliceExpr:
          source: 'AEBDc[P * 0 : P]'
          var: AEBDc
          offset: 0
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 81
      carry1:
        SliceExpr:
          source: 'AEBDc[P * 1 : P]'
          var: AEBDc
          offset: 81
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 81
      AFBE:
        FuncExpr:
          source: 'addProduct<P>(AF, BE)'
          name: addProduct_81
          args:
          - 
            SliceExpr:
              source: 'AF'
              var: AF
              offset: 0
              size: 162
          - 
            SliceExpr:
              source: 'BE'
              var: BE
              offset: 0
              size: 162
      AFBEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(AFBE.value, carry1, 0)'
          name: addCarryToProduct_81
          args:
          - 
            SliceExpr:
              source: 'AFBE.value'
              var: AFBE
              offset: 0
              size: 162
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry1'
              var: carry1
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      AFBEcCD:
        FuncExpr:
          source: 'addProduct<P>(AFBEc, CD)'
          name: addProduct_81
          args:
          - 
            SliceExpr:
              source: 'AFBEc'
              var: AFBEc
              offset: 0
              size: 162
          - 
            SliceExpr:
              source: 'CD'
              var: CD
              offset: 0
              size: 162
      tryte2:
        SliceExpr:
          source: 'AFBEcCD[P * 0 : P]'
          var: AFBEcCD
          offset: 0
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 81
      carry2:
        SliceExpr:
          source: 'AFBEcCD[P * 1 : P]'
          var: AFBEcCD
          offset: 81
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 81
      BFCE:
        FuncExpr:
          source: 'addProduct<P>(BF, CE)'
          name: addProduct_81
          args:
          - 
            SliceExpr:
              source: 'BF'
              var: BF
              offset: 0
              size: 162
          - 
            SliceExpr:
              source: 'CE'
              var: CE
              offset: 0
              size: 162
      BFCEc:
        FuncExpr:
          source: 'addCarryToProduct<P>(BFCE.value, carry2, 0)'
          name: addCarryToProduct_81
          args:
          - 
            SliceExpr:
              source: 'BFCE.value'
              var: BFCE
              offset: 0
              size: 162
              fields: 
                - value
          - 
            SliceExpr:
              source: 'carry2'
              var: carry2
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      tryte3:
        SliceExpr:
          source: 'BFCEc[P * 0 : P]'
          var: BFCEc
          offset: 0
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 0
          end:
            ConstTypeName:
              typeName: P
              size: 81
      carry3:
        SliceExpr:
          source: 'BFCEc[P * 1 : P]'
          var: BFCEc
          offset: 81
          size: 81
          start:
            ConstTerm:
              operator: '*'
              lhs: 
                ConstTypeName:
                  typeName: P
                  size: 81
              rhs: 
                ConstNumber:
                  value: 1
          end:
            ConstTypeName:
              typeName: P
              size: 81
      CFc:
        FuncExpr:
          source: 'addCarryToProduct<P>(CF, carry3, AFBEcCD.carry)'
          name: addCarryToProduct_81
          args:
          - 
            SliceExpr:
              source: 'CF'
              var: CF
              offset: 0
              size: 162
          - 
            SliceExpr:
              source: 'carry3'
              var: carry3
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'AFBEcCD.carry'
              var: AFBEcCD
              offset: 162
              size: 1
              fields: 
                - carry
    return: 
    # tryte0 & tryte1 & tryte2 & tryte3 & CFc
      ConcatExpr:
        source: 'tryte0 & tryte1 & tryte2 & tryte3 & CFc'
        lhs: 
          ConcatExpr:
            source: 'tryte0 & tryte1 & tryte2 & tryte3'
            lhs: 
              ConcatExpr:
                source: 'tryte0 & tryte1 & tryte2'
                lhs: 
                  ConcatExpr:
                    source: 'tryte0 & tryte1'
                    lhs: 
                      SliceExpr:
                        source: 'tryte0'
                        var: tryte0
                        offset: 0
                        size: 81
                    rhs: 
                      SliceExpr:
                        source: 'tryte1'
                        var: tryte1
                        offset: 0
                        size: 81
                rhs: 
                  SliceExpr:
                    source: 'tryte2'
                    var: tryte2
                    offset: 0
                    size: 81
            rhs: 
              SliceExpr:
                source: 'tryte3'
                var: tryte3
                offset: 0
                size: 81
        rhs: 
          SliceExpr:
            source: 'CFc'
            var: CFc
            offset: 0
            size: 162
# 
# func P2Carry addProduct<P>(P2 lhs, P2 rhs) {
#   lo = fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)
#   hi = fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)
#   return lo.value & hi
# }
  addProduct_81:
    returnType: 
      ConstTypeName:
        typeName: P2Carry
        size: 163
        fields:
          value: 
            size: '162'
            offset: '0'
          carry: 
            size: '1'
            offset: '162'
    params:
      - 
        argName: lhs
        size: 162
        type: 
          ConstTypeName:
            typeName: P2
            size: 162
      - 
        argName: rhs
        size: 162
        type: 
          ConstTypeName:
            typeName: P2
            size: 162
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], rhs[P * 0 : P], 0)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 81
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 81
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[P * 0 : P]'
              var: rhs
              offset: 0
              size: 81
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 81
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
      hi:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 1 : P], rhs[P * 1 : P], lo.carry)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 81
              size: 81
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 81
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[P * 1 : P]'
              var: rhs
              offset: 81
              size: 81
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 81
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 81
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 81
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi
      ConcatExpr:
        source: 'lo.value & hi'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 81
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi'
            var: hi
            offset: 0
            size: 82
# 
# func P2 addCarryToProduct<P>(P2 lhs, P carry, Carry extraTrit) {
#   lo = fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)
#   hi = halfAdd<P>(lhs[P * 1 : P], lo.carry)
#   return lo.value & hi.value
# }
  addCarryToProduct_81:
    returnType: 
      ConstTypeName:
        typeName: P2
        size: 162
    params:
      - 
        argName: lhs
        size: 162
        type: 
          ConstTypeName:
            typeName: P2
            size: 162
      - 
        argName: carry
        size: 81
        type: 
          ConstTypeName:
            typeName: P
            size: 81
      - 
        argName: extraTrit
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      lo:
        FuncExpr:
          source: 'fullAdd<P>(lhs[P * 0 : P], carry, extraTrit)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 0 : P]'
              var: lhs
              offset: 0
              size: 81
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 81
                  rhs: 
                    ConstNumber:
                      value: 0
              end:
                ConstTypeName:
                  typeName: P
                  size: 81
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'extraTrit'
              var: extraTrit
              offset: 0
              size: 1
      hi:
        FuncExpr:
          source: 'halfAdd<P>(lhs[P * 1 : P], lo.carry)'
          name: halfAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs[P * 1 : P]'
              var: lhs
              offset: 81
              size: 81
              start:
                ConstTerm:
                  operator: '*'
                  lhs: 
                    ConstTypeName:
                      typeName: P
                      size: 81
                  rhs: 
                    ConstNumber:
                      value: 1
              end:
                ConstTypeName:
                  typeName: P
                  size: 81
          - 
            SliceExpr:
              source: 'lo.carry'
              var: lo
              offset: 81
              size: 1
              fields: 
                - carry
    return: 
    # lo.value & hi.value
      ConcatExpr:
        source: 'lo.value & hi.value'
        lhs: 
          SliceExpr:
            source: 'lo.value'
            var: lo
            offset: 0
            size: 81
            fields: 
              - value
        rhs: 
          SliceExpr:
            source: 'hi.value'
            var: hi
            offset: 0
            size: 81
            fields: 
              - value
# 
# func Hash decr<Hash>(Hash val) {
#   halfSum = halfAdd<Hash>(val, -)
#   return halfSum.value
# }
  decr_243:
    returnType: 
      ConstTypeName:
        typeName: Hash
        size: 243
    params:
      - 
        argName: val
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
    assigns: 
      halfSum:
        FuncExpr:
          source: 'halfAdd<Hash>(val, -)'
          name: halfAdd_243
          args:
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 243
          - 
            ValueExpr:
                value: '-'
                trits: '-'
                trytes: 'Z'
    return: 
    # halfSum.value
      SliceExpr:
        source: 'halfSum.value'
        var: halfSum
        offset: 0
        size: 243
        fields: 
          - value
# 
# func TCarry halfAdd<Hash>(Hash val, Carry carry) {
#   add0 = halfAdd<A>(val[0 : A], carry)
#   add1 = halfAdd<B>(val[A : B], add0.carry)
#   add2 = halfAdd<C>(val[A + B : C], add1.carry)
#   return add0.value & add1.value & add2
# }
  halfAdd_243:
    returnType: 
      ConstTypeName:
        typeName: TCarry
        size: 244
        fields:
          value: 
            size: '243'
            offset: '0'
          carry: 
            size: '1'
            offset: '243'
    params:
      - 
        argName: val
        size: 243
        type: 
          ConstTypeName:
            typeName: Hash
            size: 243
      - 
        argName: carry
        size: 1
        type: 
          ConstTypeName:
            typeName: Carry
            size: 1
    assigns: 
      add0:
        FuncExpr:
          source: 'halfAdd<A>(val[0 : A], carry)'
          name: halfAdd_81
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 81
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 81
          - 
            SliceExpr:
              source: 'carry'
              var: carry
              offset: 0
              size: 1
      add1:
        FuncExpr:
          source: 'halfAdd<B>(val[A : B], add0.carry)'
          name: halfAdd_81
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 81
              size: 81
              start:
                ConstTypeName:
                  typeName: A
                  size: 81
              end:
                ConstTypeName:
                  typeName: B
                  size: 81
          - 
            SliceExpr:
              source: 'add0.carry'
              var: add0
              offset: 81
              size: 1
              fields: 
                - carry
      add2:
        FuncExpr:
          source: 'halfAdd<C>(val[A + B : C], add1.carry)'
          name: halfAdd_81
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 162
              size: 81
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 81
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 81
              end:
                ConstTypeName:
                  typeName: C
                  size: 81
          - 
            SliceExpr:
              source: 'add1.carry'
              var: add1
              offset: 81
              size: 1
              fields: 
                - carry
    return: 
    # add0.value & add1.value & add2
      ConcatExpr:
        source: 'add0.value & add1.value & add2'
        lhs: 
          ConcatExpr:
            source: 'add0.value & add1.value'
            lhs: 
              SliceExpr:
                source: 'add0.value'
                var: add0
                offset: 0
                size: 81
                fields: 
                  - value
            rhs: 
              SliceExpr:
                source: 'add1.value'
                var: add1
                offset: 0
                size: 81
                fields: 
                  - value
        rhs: 
          SliceExpr:
            source: 'add2'
            var: add2
            offset: 0
            size: 82
# 
# func Bool hasDivisor<Int>(Int n, Int from, Int to) {
#   sqrfrom = mul<Int>(from, from)
#   compare = cmp<Int>(sqrfrom, n)
#   return isZero[compare] ? true : notGreater[compare] ? hasDivisorCheckAll<Int>(n, from, to) : false
# }
  hasDivisor_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: from
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: to
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      sqrfrom:
        FuncExpr:
          source: 'mul<Int>(from, from)'
          name: mul_27
          args:
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 27
      compare:
        FuncExpr:
          source: 'cmp<Int>(sqrfrom, n)'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'sqrfrom'
              var: sqrfrom
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 27
    return: 
    # isZero[compare] ? true : notGreater[compare] ? hasDivisorCheckAll<Int>(n, from, to) : false
      CondExpr:
        source: 'isZero[compare] ? true : notGreater[compare] ? hasDivisorCheckAll<Int>(n, from, to) : false'
        if: 
          LutExpr:
            name: isZero
            args: 
              - 
                SliceExpr:
                  source: 'compare'
                  var: compare
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '1'
              trits: '1'
              trytes: 'A'
        else:
          CondExpr:
            source: 'notGreater[compare] ? hasDivisorCheckAll<Int>(n, from, to) : false'
            if: 
              LutExpr:
                name: notGreater
                args: 
                  - 
                    SliceExpr:
                      source: 'compare'
                      var: compare
                      offset: 0
                      size: 1
            then: 
              FuncExpr:
                source: 'hasDivisorCheckAll<Int>(n, from, to)'
                name: hasDivisorCheckAll_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'from'
                    var: from
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'to'
                    var: to
                    offset: 0
                    size: 27
            else:
              ValueExpr:
                  value: '0'
                  trits: '0'
                  trytes: '9'
# 
# func Bool isDivisor<Int>(Int n, Int divisor) {
#   t = divMod<Int>(n, divisor)
#   return equal<Int>(t.remainder, 0)
# }
  isDivisor_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: divisor
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      t:
        FuncExpr:
          source: 'divMod<Int>(n, divisor)'
          name: divMod_27
          args:
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'divisor'
              var: divisor
              offset: 0
              size: 27
    return: 
    # equal<Int>(t.remainder, 0)
      FuncExpr:
        source: 'equal<Int>(t.remainder, 0)'
        name: equal_27
        args:
        - 
          SliceExpr:
            source: 't.remainder'
            var: t
            offset: 27
            size: 27
            fields: 
              - remainder
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000'
              trytes: '999999999'
# 
# func Bool hasDivisorCheckAll<Int>(Int n, Int from, Int to) {
#   len = sub<Int>(to, from)
#   return equal<Int>(len, 0) ? isDivisor<Int>(n, from) : equal<Int>(len, 1) ? (isDivisor<Int>(n, from) ? 1 : isDivisor<Int>(n, to)) : lookDeeperForDivisors<Int>(n, from, to)
# }
  hasDivisorCheckAll_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: from
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: to
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      len:
        FuncExpr:
          source: 'sub<Int>(to, from)'
          name: sub_27
          args:
          - 
            SliceExpr:
              source: 'to'
              var: to
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 27
    return: 
    # equal<Int>(len, 0) ? isDivisor<Int>(n, from) : equal<Int>(len, 1) ? (isDivisor<Int>(n, from) ? 1 : isDivisor<Int>(n, to)) : lookDeeperForDivisors<Int>(n, from, to)
      CondExpr:
        source: 'equal<Int>(len, 0) ? isDivisor<Int>(n, from) : equal<Int>(len, 1) ? (isDivisor<Int>(n, from) ? 1 : isDivisor<Int>(n, to)) : lookDeeperForDivisors<Int>(n, from, to)'
        if: 
          FuncExpr:
            source: 'equal<Int>(len, 0)'
            name: equal_27
            args:
            - 
              SliceExpr:
                source: 'len'
                var: len
                offset: 0
                size: 27
            - 
              ValueExpr:
                  value: '0'
                  trits: '000000000000000000000000000'
                  trytes: '999999999'
        then: 
          FuncExpr:
            source: 'isDivisor<Int>(n, from)'
            name: isDivisor_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'from'
                var: from
                offset: 0
                size: 27
        else:
          CondExpr:
            source: 'equal<Int>(len, 1) ? (isDivisor<Int>(n, from) ? 1 : isDivisor<Int>(n, to)) : lookDeeperForDivisors<Int>(n, from, to)'
            if: 
              FuncExpr:
                source: 'equal<Int>(len, 1)'
                name: equal_27
                args:
                - 
                  SliceExpr:
                    source: 'len'
                    var: len
                    offset: 0
                    size: 27
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000'
                      trytes: 'A99999999'
            then: 
              CondExpr:
                source: 'isDivisor<Int>(n, from) ? 1 : isDivisor<Int>(n, to)'
                if: 
                  FuncExpr:
                    source: 'isDivisor<Int>(n, from)'
                    name: isDivisor_27
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 27
                    - 
                      SliceExpr:
                        source: 'from'
                        var: from
                        offset: 0
                        size: 27
                then: 
                  ValueExpr:
                      value: '1'
                      trits: '1'
                      trytes: 'A'
                else:
                  FuncExpr:
                    source: 'isDivisor<Int>(n, to)'
                    name: isDivisor_27
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 27
                    - 
                      SliceExpr:
                        source: 'to'
                        var: to
                        offset: 0
                        size: 27
            else:
              FuncExpr:
                source: 'lookDeeperForDivisors<Int>(n, from, to)'
                name: lookDeeperForDivisors_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'from'
                    var: from
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'to'
                    var: to
                    offset: 0
                    size: 27
# 
# func Bool lookDeeperForDivisors<Int>(Int n, Int from, Int to) {
#   div3 = lshift<Int>(sub<Int>(to, from))
#   i1 = add<Int>(from, div3)
#   i2 = add<Int>(i1, div3)
#   return hasDivisor<Int>(n, from, i1) ? true : hasDivisor<Int>(n, i1, i2) ? hasDivisor<Int>(n, i2, to) : false
# }
  lookDeeperForDivisors_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: from
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: to
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      div3:
        FuncExpr:
          source: 'lshift<Int>(sub<Int>(to, from))'
          name: lshift_27
          args:
          - 
            FuncExpr:
              source: 'sub<Int>(to, from)'
              name: sub_27
              args:
              - 
                SliceExpr:
                  source: 'to'
                  var: to
                  offset: 0
                  size: 27
              - 
                SliceExpr:
                  source: 'from'
                  var: from
                  offset: 0
                  size: 27
      i1:
        FuncExpr:
          source: 'add<Int>(from, div3)'
          name: add_27
          args:
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 27
      i2:
        FuncExpr:
          source: 'add<Int>(i1, div3)'
          name: add_27
          args:
          - 
            SliceExpr:
              source: 'i1'
              var: i1
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 27
    return: 
    # hasDivisor<Int>(n, from, i1) ? true : hasDivisor<Int>(n, i1, i2) ? hasDivisor<Int>(n, i2, to) : false
      CondExpr:
        source: 'hasDivisor<Int>(n, from, i1) ? true : hasDivisor<Int>(n, i1, i2) ? hasDivisor<Int>(n, i2, to) : false'
        if: 
          FuncExpr:
            source: 'hasDivisor<Int>(n, from, i1)'
            name: hasDivisor_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'from'
                var: from
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'i1'
                var: i1
                offset: 0
                size: 27
        then: 
          ValueExpr:
              value: '1'
              trits: '1'
              trytes: 'A'
        else:
          CondExpr:
            source: 'hasDivisor<Int>(n, i1, i2) ? hasDivisor<Int>(n, i2, to) : false'
            if: 
              FuncExpr:
                source: 'hasDivisor<Int>(n, i1, i2)'
                name: hasDivisor_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'i1'
                    var: i1
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'i2'
                    var: i2
                    offset: 0
                    size: 27
            then: 
              FuncExpr:
                source: 'hasDivisor<Int>(n, i2, to)'
                name: hasDivisor_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'i2'
                    var: i2
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'to'
                    var: to
                    offset: 0
                    size: 27
            else:
              ValueExpr:
                  value: '0'
                  trits: '0'
                  trytes: '9'
# 
# func Bool isPrime<Int>(Int n) {
#   return or[equal<Int>(n, 1), or[equal<Int>(n, 2), equal<Int>(n, 3)]] ? 1 : not[hasDivisor<Int>(n, 2, sub<Int>(n, 1))]
# }
  isPrime_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # or[equal<Int>(n, 1), or[equal<Int>(n, 2), equal<Int>(n, 3)]] ? 1 : not[hasDivisor<Int>(n, 2, sub<Int>(n, 1))]
      CondExpr:
        source: 'or[equal<Int>(n, 1), or[equal<Int>(n, 2), equal<Int>(n, 3)]] ? 1 : not[hasDivisor<Int>(n, 2, sub<Int>(n, 1))]'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                FuncExpr:
                  source: 'equal<Int>(n, 1)'
                  name: equal_27
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 27
                  - 
                    ValueExpr:
                        value: '1'
                        trits: '100000000000000000000000000'
                        trytes: 'A99999999'
              - 
                LutExpr:
                  name: or
                  args: 
                    - 
                      FuncExpr:
                        source: 'equal<Int>(n, 2)'
                        name: equal_27
                        args:
                        - 
                          SliceExpr:
                            source: 'n'
                            var: n
                            offset: 0
                            size: 27
                        - 
                          ValueExpr:
                              value: '2'
                              trits: '-10000000000000000000000000'
                              trytes: 'B99999999'
                    - 
                      FuncExpr:
                        source: 'equal<Int>(n, 3)'
                        name: equal_27
                        args:
                        - 
                          SliceExpr:
                            source: 'n'
                            var: n
                            offset: 0
                            size: 27
                        - 
                          ValueExpr:
                              value: '3'
                              trits: '010000000000000000000000000'
                              trytes: 'C99999999'
        then: 
          ValueExpr:
              value: '1'
              trits: '1'
              trytes: 'A'
        else:
          LutExpr:
            name: not
            args: 
              - 
                FuncExpr:
                  source: 'hasDivisor<Int>(n, 2, sub<Int>(n, 1))'
                  name: hasDivisor_27
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 27
                  - 
                    ValueExpr:
                        value: '2'
                        trits: '-10000000000000000000000000'
                        trytes: 'B99999999'
                  - 
                    FuncExpr:
                      source: 'sub<Int>(n, 1)'
                      name: sub_27
                      args:
                      - 
                        SliceExpr:
                          source: 'n'
                          var: n
                          offset: 0
                          size: 27
                      - 
                        ValueExpr:
                            value: '1'
                            trits: '100000000000000000000000000'
                            trytes: 'A99999999'
# 
# func Int primesList<Int>(Int from, Int to) {
#   dummy = (isPrime<Int>(from) ? print<Int>(from) : as<Int>(0))
#   return equal<Int>(from, to) ? dummy : primesList<Int>(incr<Int>(from), to)
# }
  primesList_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: from
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: to
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      dummy:
        CondExpr:
          source: 'isPrime<Int>(from) ? print<Int>(from) : as<Int>(0)'
          if: 
            FuncExpr:
              source: 'isPrime<Int>(from)'
              name: isPrime_27
              args:
              - 
                SliceExpr:
                  source: 'from'
                  var: from
                  offset: 0
                  size: 27
          then: 
            FuncExpr:
              source: 'print<Int>(from)'
              name: print_27
              args:
              - 
                SliceExpr:
                  source: 'from'
                  var: from
                  offset: 0
                  size: 27
          else:
            FuncExpr:
              source: 'as<Int>(0)'
              name: as_27
              args:
              - 
                ValueExpr:
                    value: '0'
                    trits: '000000000000000000000000000'
                    trytes: '999999999'
    return: 
    # equal<Int>(from, to) ? dummy : primesList<Int>(incr<Int>(from), to)
      CondExpr:
        source: 'equal<Int>(from, to) ? dummy : primesList<Int>(incr<Int>(from), to)'
        if: 
          FuncExpr:
            source: 'equal<Int>(from, to)'
            name: equal_27
            args:
            - 
              SliceExpr:
                source: 'from'
                var: from
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'to'
                var: to
                offset: 0
                size: 27
        then: 
          SliceExpr:
            source: 'dummy'
            var: dummy
            offset: 0
            size: 27
        else:
          FuncExpr:
            source: 'primesList<Int>(incr<Int>(from), to)'
            name: primesList_27
            args:
            - 
              FuncExpr:
                source: 'incr<Int>(from)'
                name: incr_27
                args:
                - 
                  SliceExpr:
                    source: 'from'
                    var: from
                    offset: 0
                    size: 27
            - 
              SliceExpr:
                source: 'to'
                var: to
                offset: 0
                size: 27
# 
# func Int mul<Int>(Int lhs, Int rhs) {
#   lhsZero = isZero[sign<Int>(lhs)]
#   rhsZero = isZero[sign<Int>(rhs)]
#   product = fullMulNonZero<Int>(lhs, rhs)
#   return or[lhsZero, rhsZero] ? 0 : product[0 : Int]
# }
  mul_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      lhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Int>(lhs)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'lhs'
                    var: lhs
                    offset: 0
                    size: 27
      rhsZero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Int>(rhs)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'rhs'
                    var: rhs
                    offset: 0
                    size: 27
      product:
        FuncExpr:
          source: 'fullMulNonZero<Int>(lhs, rhs)'
          name: fullMulNonZero_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
    return: 
    # or[lhsZero, rhsZero] ? 0 : product[0 : Int]
      CondExpr:
        source: 'or[lhsZero, rhsZero] ? 0 : product[0 : Int]'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                SliceExpr:
                  source: 'lhsZero'
                  var: lhsZero
                  offset: 0
                  size: 1
              - 
                SliceExpr:
                  source: 'rhsZero'
                  var: rhsZero
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000'
              trytes: '999999999'
        else:
          SliceExpr:
            source: 'product[0 : Int]'
            var: product
            offset: 0
            size: 27
            start:
              ConstNumber:
                value: 0
            end:
              ConstTypeName:
                typeName: Int
                size: 27
# 
# func Trit cmp<Int>(Int lhs, Int rhs) {
#   val0 = cmp<A>(lhs[0 : A], rhs[0 : A])
#   val1 = cmp<B>(lhs[A : B], rhs[A : B])
#   val2 = cmp<C>(lhs[A + B : C], rhs[A + B : C])
#   return sign[val0, val1, val2]
# }
  cmp_27:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      val0:
        FuncExpr:
          source: 'cmp<A>(lhs[0 : A], rhs[0 : A])'
          name: cmp_9
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
      val1:
        FuncExpr:
          source: 'cmp<B>(lhs[A : B], rhs[A : B])'
          name: cmp_9
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
      val2:
        FuncExpr:
          source: 'cmp<C>(lhs[A + B : C], rhs[A + B : C])'
          name: cmp_9
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Trit cmp<A>(A lhs, A rhs) {
#   val0 = cmp<A>(lhs[0 : A], rhs[0 : A])
#   val1 = cmp<B>(lhs[A : B], rhs[A : B])
#   val2 = cmp<C>(lhs[A + B : C], rhs[A + B : C])
#   return sign[val0, val1, val2]
# }
  cmp_9:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
      - 
        argName: rhs
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
    assigns: 
      val0:
        FuncExpr:
          source: 'cmp<A>(lhs[0 : A], rhs[0 : A])'
          name: cmp_3
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
      val1:
        FuncExpr:
          source: 'cmp<B>(lhs[A : B], rhs[A : B])'
          name: cmp_3
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
      val2:
        FuncExpr:
          source: 'cmp<C>(lhs[A + B : C], rhs[A + B : C])'
          name: cmp_3
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Trit cmp<A>(A lhs, A rhs) {
#   val0 = cmp<A>(lhs[0 : A], rhs[0 : A])
#   val1 = cmp<B>(lhs[A : B], rhs[A : B])
#   val2 = cmp<C>(lhs[A + B : C], rhs[A + B : C])
#   return sign[val0, val1, val2]
# }
  cmp_3:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
      - 
        argName: rhs
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
    assigns: 
      val0:
        FuncExpr:
          source: 'cmp<A>(lhs[0 : A], rhs[0 : A])'
          name: cmp_1
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
      val1:
        FuncExpr:
          source: 'cmp<B>(lhs[A : B], rhs[A : B])'
          name: cmp_1
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
      val2:
        FuncExpr:
          source: 'cmp<C>(lhs[A + B : C], rhs[A + B : C])'
          name: cmp_1
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Int sub<Int>(Int lhs, Int rhs) {
#   sum = fullAdd<Int>(lhs, neg<Int>(rhs), 0)
#   return sum.value
# }
  sub_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Int>(lhs, neg<Int>(rhs), 0)'
          name: fullAdd_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            FuncExpr:
              source: 'neg<Int>(rhs)'
              name: neg_27
              args:
              - 
                SliceExpr:
                  source: 'rhs'
                  var: rhs
                  offset: 0
                  size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 27
        fields: 
          - value
# 
# func Int neg<Int>(Int val) {
#   val0 = neg<A>(val[0 : A])
#   val1 = neg<B>(val[A : B])
#   val2 = neg<C>(val[A + B : C])
#   return val0 & val1 & val2
# }
  neg_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      val0:
        FuncExpr:
          source: 'neg<A>(val[0 : A])'
          name: neg_9
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
      val1:
        FuncExpr:
          source: 'neg<B>(val[A : B])'
          name: neg_9
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
      val2:
        FuncExpr:
          source: 'neg<C>(val[A + B : C])'
          name: neg_9
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
    return: 
    # val0 & val1 & val2
      ConcatExpr:
        source: 'val0 & val1 & val2'
        lhs: 
          ConcatExpr:
            source: 'val0 & val1'
            lhs: 
              SliceExpr:
                source: 'val0'
                var: val0
                offset: 0
                size: 9
            rhs: 
              SliceExpr:
                source: 'val1'
                var: val1
                offset: 0
                size: 9
        rhs: 
          SliceExpr:
            source: 'val2'
            var: val2
            offset: 0
            size: 9
# 
# func A neg<A>(A val) {
#   val0 = neg<A>(val[0 : A])
#   val1 = neg<B>(val[A : B])
#   val2 = neg<C>(val[A + B : C])
#   return val0 & val1 & val2
# }
  neg_9:
    returnType: 
      ConstTypeName:
        typeName: A
        size: 9
    params:
      - 
        argName: val
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
    assigns: 
      val0:
        FuncExpr:
          source: 'neg<A>(val[0 : A])'
          name: neg_3
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
      val1:
        FuncExpr:
          source: 'neg<B>(val[A : B])'
          name: neg_3
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
      val2:
        FuncExpr:
          source: 'neg<C>(val[A + B : C])'
          name: neg_3
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
    return: 
    # val0 & val1 & val2
      ConcatExpr:
        source: 'val0 & val1 & val2'
        lhs: 
          ConcatExpr:
            source: 'val0 & val1'
            lhs: 
              SliceExpr:
                source: 'val0'
                var: val0
                offset: 0
                size: 3
            rhs: 
              SliceExpr:
                source: 'val1'
                var: val1
                offset: 0
                size: 3
        rhs: 
          SliceExpr:
            source: 'val2'
            var: val2
            offset: 0
            size: 3
# 
# func A neg<A>(A val) {
#   val0 = neg<A>(val[0 : A])
#   val1 = neg<B>(val[A : B])
#   val2 = neg<C>(val[A + B : C])
#   return val0 & val1 & val2
# }
  neg_3:
    returnType: 
      ConstTypeName:
        typeName: A
        size: 3
    params:
      - 
        argName: val
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
    assigns: 
      val0:
        FuncExpr:
          source: 'neg<A>(val[0 : A])'
          name: neg_1
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
      val1:
        FuncExpr:
          source: 'neg<B>(val[A : B])'
          name: neg_1
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
      val2:
        FuncExpr:
          source: 'neg<C>(val[A + B : C])'
          name: neg_1
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
    return: 
    # val0 & val1 & val2
      ConcatExpr:
        source: 'val0 & val1 & val2'
        lhs: 
          ConcatExpr:
            source: 'val0 & val1'
            lhs: 
              SliceExpr:
                source: 'val0'
                var: val0
                offset: 0
                size: 1
            rhs: 
              SliceExpr:
                source: 'val1'
                var: val1
                offset: 0
                size: 1
        rhs: 
          SliceExpr:
            source: 'val2'
            var: val2
            offset: 0
            size: 1
# 
# func Bool equal<Int>(Int lhs, Int rhs) {
#   val0 = equal<A>(lhs[0 : A], rhs[0 : A])
#   val1 = equal<B>(lhs[A : B], rhs[A : B])
#   val2 = equal<C>(lhs[A + B : C], rhs[A + B : C])
#   return and3[val0, val1, val2]
# }
  equal_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      val0:
        FuncExpr:
          source: 'equal<A>(lhs[0 : A], rhs[0 : A])'
          name: equal_9
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
      val1:
        FuncExpr:
          source: 'equal<B>(lhs[A : B], rhs[A : B])'
          name: equal_9
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
      val2:
        FuncExpr:
          source: 'equal<C>(lhs[A + B : C], rhs[A + B : C])'
          name: equal_9
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
    return: 
    # and3[val0, val1, val2]
      LutExpr:
        name: and3
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Bool equal<A>(A lhs, A rhs) {
#   val0 = equal<A>(lhs[0 : A], rhs[0 : A])
#   val1 = equal<B>(lhs[A : B], rhs[A : B])
#   val2 = equal<C>(lhs[A + B : C], rhs[A + B : C])
#   return and3[val0, val1, val2]
# }
  equal_9:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: lhs
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
      - 
        argName: rhs
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
    assigns: 
      val0:
        FuncExpr:
          source: 'equal<A>(lhs[0 : A], rhs[0 : A])'
          name: equal_3
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
      val1:
        FuncExpr:
          source: 'equal<B>(lhs[A : B], rhs[A : B])'
          name: equal_3
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
      val2:
        FuncExpr:
          source: 'equal<C>(lhs[A + B : C], rhs[A + B : C])'
          name: equal_3
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
    return: 
    # and3[val0, val1, val2]
      LutExpr:
        name: and3
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Bool equal<A>(A lhs, A rhs) {
#   val0 = equal<A>(lhs[0 : A], rhs[0 : A])
#   val1 = equal<B>(lhs[A : B], rhs[A : B])
#   val2 = equal<C>(lhs[A + B : C], rhs[A + B : C])
#   return and3[val0, val1, val2]
# }
  equal_3:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: lhs
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
      - 
        argName: rhs
        size: 3
        type: 
          ConstTypeName:
            typeName: A
            size: 3
    assigns: 
      val0:
        FuncExpr:
          source: 'equal<A>(lhs[0 : A], rhs[0 : A])'
          name: equal_1
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 1
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 1
      val1:
        FuncExpr:
          source: 'equal<B>(lhs[A : B], rhs[A : B])'
          name: equal_1
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 1
              size: 1
              start:
                ConstTypeName:
                  typeName: A
                  size: 1
              end:
                ConstTypeName:
                  typeName: B
                  size: 1
      val2:
        FuncExpr:
          source: 'equal<C>(lhs[A + B : C], rhs[A + B : C])'
          name: equal_1
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 2
              size: 1
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 1
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 1
              end:
                ConstTypeName:
                  typeName: C
                  size: 1
    return: 
    # and3[val0, val1, val2]
      LutExpr:
        name: and3
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func T2 divMod<Int>(Int lhs, Int rhs) {
#   absLhs = abs<Int>(lhs)
#   absRhs = abs<Int>(rhs)
#   quorem = roundDivModLoop<Int>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   fix = isNegative[sign<Int>(rem)]
#   quo0 = fix ? decr<Int>(quo) : quo
#   rem0 = fix ? add<Int>(rem, absRhs) : rem
#   return fixSign<Int>(lhs, rhs, quo0, rem0)
# }
  divMod_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Int>(lhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      absRhs:
        FuncExpr:
          source: 'abs<Int>(rhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Int>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_27
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000'
                trytes: '999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000'
                trytes: 'A99999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 27
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 27
          size: 27
          fields: 
            - remainder
      fix:
        LutExpr:
          name: isNegative
          args: 
            - 
              FuncExpr:
                source: 'sign<Int>(rem)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'rem'
                    var: rem
                    offset: 0
                    size: 27
      quo0:
        CondExpr:
          source: 'fix ? decr<Int>(quo) : quo'
          if: 
            SliceExpr:
              source: 'fix'
              var: fix
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'decr<Int>(quo)'
              name: decr_27
              args:
              - 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 27
          else:
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 27
      rem0:
        CondExpr:
          source: 'fix ? add<Int>(rem, absRhs) : rem'
          if: 
            SliceExpr:
              source: 'fix'
              var: fix
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'add<Int>(rem, absRhs)'
              name: add_27
              args:
              - 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 27
              - 
                SliceExpr:
                  source: 'absRhs'
                  var: absRhs
                  offset: 0
                  size: 27
          else:
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
    return: 
    # fixSign<Int>(lhs, rhs, quo0, rem0)
      FuncExpr:
        source: 'fixSign<Int>(lhs, rhs, quo0, rem0)'
        name: fixSign_27
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'quo0'
            var: quo0
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rem0'
            var: rem0
            offset: 0
            size: 27
# 
# func T2 ceilDivMod<Int>(Int lhs, Int rhs) {
#   absLhs = abs<Int>(lhs)
#   absRhs = abs<Int>(rhs)
#   quorem = roundDivModLoop<Int>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   lhsSign = sign<Int>(lhs)
#   rhsSign = sign<Int>(rhs)
#   remSign = sign<Int>(rem)
#   neg = xor[isNegative[lhsSign], isNegative[rhsSign]]
#   up = and[not[neg], isPositive[remSign]]
#   down = and[neg, isNegative[remSign]]
#   none = nor[up, down]
#   quoN0 = none ? quo : null
#   quoN1 = incr<Int>(up ? quo : null)
#   quoN2 = decr<Int>(down ? quo : null)
#   quo0 = quoN0 | quoN1 | quoN2
#   remN0 = none ? rem : null
#   remN1 = sub<Int>(up ? rem : null, absRhs)
#   remN2 = add<Int>(down ? rem : null, absRhs)
#   rem0 = remN0 | remN1 | remN2
#   return fixSign<Int>(lhs, rhs, quo0, rem0)
# }
  ceilDivMod_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Int>(lhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      absRhs:
        FuncExpr:
          source: 'abs<Int>(rhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Int>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_27
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000'
                trytes: '999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000'
                trytes: 'A99999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 27
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 27
          size: 27
          fields: 
            - remainder
      lhsSign:
        FuncExpr:
          source: 'sign<Int>(lhs)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      rhsSign:
        FuncExpr:
          source: 'sign<Int>(rhs)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      remSign:
        FuncExpr:
          source: 'sign<Int>(rem)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
      neg:
        LutExpr:
          name: xor
          args: 
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'lhsSign'
                      var: lhsSign
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'rhsSign'
                      var: rhsSign
                      offset: 0
                      size: 1
      up:
        LutExpr:
          name: and
          args: 
            - 
              LutExpr:
                name: not
                args: 
                  - 
                    SliceExpr:
                      source: 'neg'
                      var: neg
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isPositive
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      down:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'neg'
                var: neg
                offset: 0
                size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      none:
        LutExpr:
          name: nor
          args: 
            - 
              SliceExpr:
                source: 'up'
                var: up
                offset: 0
                size: 1
            - 
              SliceExpr:
                source: 'down'
                var: down
                offset: 0
                size: 1
      quoN0:
        CondExpr:
          source: 'none ? quo : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 27
          else:
            NullExpr: ''
      quoN1:
        FuncExpr:
          source: 'incr<Int>(up ? quo : null)'
          name: incr_27
          args:
          - 
            CondExpr:
              source: 'up ? quo : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
      quoN2:
        FuncExpr:
          source: 'decr<Int>(down ? quo : null)'
          name: decr_27
          args:
          - 
            CondExpr:
              source: 'down ? quo : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
      quo0:
        MergeExpr:
          source: 'quoN0 | quoN1 | quoN2'
          lhs: 
            MergeExpr:
              source: 'quoN0 | quoN1'
              lhs: 
                SliceExpr:
                  source: 'quoN0'
                  var: quoN0
                  offset: 0
                  size: 27
              rhs: 
                SliceExpr:
                  source: 'quoN1'
                  var: quoN1
                  offset: 0
                  size: 27
          rhs: 
            SliceExpr:
              source: 'quoN2'
              var: quoN2
              offset: 0
              size: 27
      remN0:
        CondExpr:
          source: 'none ? rem : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
          else:
            NullExpr: ''
      remN1:
        FuncExpr:
          source: 'sub<Int>(up ? rem : null, absRhs)'
          name: sub_27
          args:
          - 
            CondExpr:
              source: 'up ? rem : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
      remN2:
        FuncExpr:
          source: 'add<Int>(down ? rem : null, absRhs)'
          name: add_27
          args:
          - 
            CondExpr:
              source: 'down ? rem : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
      rem0:
        MergeExpr:
          source: 'remN0 | remN1 | remN2'
          lhs: 
            MergeExpr:
              source: 'remN0 | remN1'
              lhs: 
                SliceExpr:
                  source: 'remN0'
                  var: remN0
                  offset: 0
                  size: 27
              rhs: 
                SliceExpr:
                  source: 'remN1'
                  var: remN1
                  offset: 0
                  size: 27
          rhs: 
            SliceExpr:
              source: 'remN2'
              var: remN2
              offset: 0
              size: 27
    return: 
    # fixSign<Int>(lhs, rhs, quo0, rem0)
      FuncExpr:
        source: 'fixSign<Int>(lhs, rhs, quo0, rem0)'
        name: fixSign_27
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'quo0'
            var: quo0
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rem0'
            var: rem0
            offset: 0
            size: 27
# 
# func T2 floorDivMod<Int>(Int lhs, Int rhs) {
#   absLhs = abs<Int>(lhs)
#   absRhs = abs<Int>(rhs)
#   quorem = roundDivModLoop<Int>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   lhsSign = sign<Int>(lhs)
#   rhsSign = sign<Int>(rhs)
#   remSign = sign<Int>(rem)
#   neg = xor[isNegative[lhsSign], isNegative[rhsSign]]
#   down = and[not[neg], isNegative[remSign]]
#   up = and[neg, isPositive[remSign]]
#   none = nor[up, down]
#   quoN0 = none ? quo : null
#   quoN1 = incr<Int>(up ? quo : null)
#   quoN2 = decr<Int>(down ? quo : null)
#   quo0 = quoN0 | quoN1 | quoN2
#   remN0 = none ? rem : null
#   remN1 = sub<Int>(up ? rem : null, absRhs)
#   remN2 = add<Int>(down ? rem : null, absRhs)
#   rem0 = remN0 | remN1 | remN2
#   return fixSign<Int>(lhs, rhs, quo0, rem0)
# }
  floorDivMod_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Int>(lhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      absRhs:
        FuncExpr:
          source: 'abs<Int>(rhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Int>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_27
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000'
                trytes: '999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000'
                trytes: 'A99999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 27
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 27
          size: 27
          fields: 
            - remainder
      lhsSign:
        FuncExpr:
          source: 'sign<Int>(lhs)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      rhsSign:
        FuncExpr:
          source: 'sign<Int>(rhs)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      remSign:
        FuncExpr:
          source: 'sign<Int>(rem)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
      neg:
        LutExpr:
          name: xor
          args: 
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'lhsSign'
                      var: lhsSign
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'rhsSign'
                      var: rhsSign
                      offset: 0
                      size: 1
      down:
        LutExpr:
          name: and
          args: 
            - 
              LutExpr:
                name: not
                args: 
                  - 
                    SliceExpr:
                      source: 'neg'
                      var: neg
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      up:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'neg'
                var: neg
                offset: 0
                size: 1
            - 
              LutExpr:
                name: isPositive
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      none:
        LutExpr:
          name: nor
          args: 
            - 
              SliceExpr:
                source: 'up'
                var: up
                offset: 0
                size: 1
            - 
              SliceExpr:
                source: 'down'
                var: down
                offset: 0
                size: 1
      quoN0:
        CondExpr:
          source: 'none ? quo : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 27
          else:
            NullExpr: ''
      quoN1:
        FuncExpr:
          source: 'incr<Int>(up ? quo : null)'
          name: incr_27
          args:
          - 
            CondExpr:
              source: 'up ? quo : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
      quoN2:
        FuncExpr:
          source: 'decr<Int>(down ? quo : null)'
          name: decr_27
          args:
          - 
            CondExpr:
              source: 'down ? quo : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
      quo0:
        MergeExpr:
          source: 'quoN0 | quoN1 | quoN2'
          lhs: 
            MergeExpr:
              source: 'quoN0 | quoN1'
              lhs: 
                SliceExpr:
                  source: 'quoN0'
                  var: quoN0
                  offset: 0
                  size: 27
              rhs: 
                SliceExpr:
                  source: 'quoN1'
                  var: quoN1
                  offset: 0
                  size: 27
          rhs: 
            SliceExpr:
              source: 'quoN2'
              var: quoN2
              offset: 0
              size: 27
      remN0:
        CondExpr:
          source: 'none ? rem : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
          else:
            NullExpr: ''
      remN1:
        FuncExpr:
          source: 'sub<Int>(up ? rem : null, absRhs)'
          name: sub_27
          args:
          - 
            CondExpr:
              source: 'up ? rem : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
      remN2:
        FuncExpr:
          source: 'add<Int>(down ? rem : null, absRhs)'
          name: add_27
          args:
          - 
            CondExpr:
              source: 'down ? rem : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 27
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
      rem0:
        MergeExpr:
          source: 'remN0 | remN1 | remN2'
          lhs: 
            MergeExpr:
              source: 'remN0 | remN1'
              lhs: 
                SliceExpr:
                  source: 'remN0'
                  var: remN0
                  offset: 0
                  size: 27
              rhs: 
                SliceExpr:
                  source: 'remN1'
                  var: remN1
                  offset: 0
                  size: 27
          rhs: 
            SliceExpr:
              source: 'remN2'
              var: remN2
              offset: 0
              size: 27
    return: 
    # fixSign<Int>(lhs, rhs, quo0, rem0)
      FuncExpr:
        source: 'fixSign<Int>(lhs, rhs, quo0, rem0)'
        name: fixSign_27
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'quo0'
            var: quo0
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rem0'
            var: rem0
            offset: 0
            size: 27
# 
# func T2 roundDivMod<Int>(Int lhs, Int rhs) {
#   absLhs = abs<Int>(lhs)
#   absRhs = abs<Int>(rhs)
#   quorem = roundDivModLoop<Int>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   return fixSign<Int>(lhs, rhs, quo, rem)
# }
  roundDivMod_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Int>(lhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      absRhs:
        FuncExpr:
          source: 'abs<Int>(rhs)'
          name: abs_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Int>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_27
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000'
                trytes: '999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000'
                trytes: 'A99999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 27
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 27
          size: 27
          fields: 
            - remainder
    return: 
    # fixSign<Int>(lhs, rhs, quo, rem)
      FuncExpr:
        source: 'fixSign<Int>(lhs, rhs, quo, rem)'
        name: fixSign_27
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'quo'
            var: quo
            offset: 0
            size: 27
        - 
          SliceExpr:
            source: 'rem'
            var: rem
            offset: 0
            size: 27
# 
# func T2 roundDivModLoop<Int>(Int quo, Int rem, Int div, Int shf) {
#   quorem = roundDivModPass<Int>(quo, rem, div)
#   newShf = rshift<Int>(shf)
#   zero = isZero[sign<Int>(newShf)]
#   quo1 = quorem.quotient
#   rem1 = quorem.remainder
#   return zero ? quorem : roundDivModLoop<Int>(quo1, rem1, div, newShf)
# }
  roundDivModLoop_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: quo
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rem
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: div
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: shf
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      quorem:
        FuncExpr:
          source: 'roundDivModPass<Int>(quo, rem, div)'
          name: roundDivModPass_27
          args:
          - 
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div'
              var: div
              offset: 0
              size: 27
      newShf:
        FuncExpr:
          source: 'rshift<Int>(shf)'
          name: rshift_27
          args:
          - 
            SliceExpr:
              source: 'shf'
              var: shf
              offset: 0
              size: 27
      zero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Int>(newShf)'
                name: sign_27
                args:
                - 
                  SliceExpr:
                    source: 'newShf'
                    var: newShf
                    offset: 0
                    size: 27
      quo1:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 27
          fields: 
            - quotient
      rem1:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 27
          size: 27
          fields: 
            - remainder
    return: 
    # zero ? quorem : roundDivModLoop<Int>(quo1, rem1, div, newShf)
      CondExpr:
        source: 'zero ? quorem : roundDivModLoop<Int>(quo1, rem1, div, newShf)'
        if: 
          SliceExpr:
            source: 'zero'
            var: zero
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'quorem'
            var: quorem
            offset: 0
            size: 54
        else:
          FuncExpr:
            source: 'roundDivModLoop<Int>(quo1, rem1, div, newShf)'
            name: roundDivModLoop_27
            args:
            - 
              SliceExpr:
                source: 'quo1'
                var: quo1
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'rem1'
                var: rem1
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'div'
                var: div
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'newShf'
                var: newShf
                offset: 0
                size: 27
# 
# func T2 roundDivModPass<Int>(Int quo, Int rem, Int div) {
#   quorem = as<T2>(rshift<T2>(quo & rem))
#   quo0 = quorem.quotient
#   rem0 = quorem.remainder
#   remSign = sign<Int>(rem0)
#   quoSign = sign<Int>(quo0)
#   low = sub<Int>(rem0, div)
#   neg1 = neg<Int>(low)
#   cmp1 = cmp<Int>(neg1, rem0)
#   posRem = isPositive[remSign]
#   posQuo = isPositive[quoSign]
#   test1 = and[posRem, or[isLess[cmp1], and[isZero[cmp1], posQuo]]]
#   high = add<Int>(rem0, div)
#   neg2 = neg<Int>(high)
#   cmp2 = cmp<Int>(neg2, rem0)
#   negRem = isNegative[remSign]
#   negQuo = isNegative[quoSign]
#   test2 = and[negRem, or[isGreater[cmp2], and[isEqual[cmp2], negQuo]]]
#   quorem1 = T2{
#     quotient = incr<Int>(quo0)
#     remainder = low
#   }
#   quorem2 = T2{
#     quotient = decr<Int>(quo0)
#     remainder = high
#   }
#   return test1 ? quorem1 : test2 ? quorem2 : quorem
# }
  roundDivModPass_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: quo
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rem
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: div
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      quorem:
        FuncExpr:
          source: 'as<T2>(rshift<T2>(quo & rem))'
          name: as_54
          args:
          - 
            FuncExpr:
              source: 'rshift<T2>(quo & rem)'
              name: rshift_54
              args:
              - 
                ConcatExpr:
                  source: 'quo & rem'
                  lhs: 
                    SliceExpr:
                      source: 'quo'
                      var: quo
                      offset: 0
                      size: 27
                  rhs: 
                    SliceExpr:
                      source: 'rem'
                      var: rem
                      offset: 0
                      size: 27
      quo0:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 27
          fields: 
            - quotient
      rem0:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 27
          size: 27
          fields: 
            - remainder
      remSign:
        FuncExpr:
          source: 'sign<Int>(rem0)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 27
      quoSign:
        FuncExpr:
          source: 'sign<Int>(quo0)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'quo0'
              var: quo0
              offset: 0
              size: 27
      low:
        FuncExpr:
          source: 'sub<Int>(rem0, div)'
          name: sub_27
          args:
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div'
              var: div
              offset: 0
              size: 27
      neg1:
        FuncExpr:
          source: 'neg<Int>(low)'
          name: neg_27
          args:
          - 
            SliceExpr:
              source: 'low'
              var: low
              offset: 0
              size: 27
      cmp1:
        FuncExpr:
          source: 'cmp<Int>(neg1, rem0)'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'neg1'
              var: neg1
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 27
      posRem:
        LutExpr:
          name: isPositive
          args: 
            - 
              SliceExpr:
                source: 'remSign'
                var: remSign
                offset: 0
                size: 1
      posQuo:
        LutExpr:
          name: isPositive
          args: 
            - 
              SliceExpr:
                source: 'quoSign'
                var: quoSign
                offset: 0
                size: 1
      test1:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'posRem'
                var: posRem
                offset: 0
                size: 1
            - 
              LutExpr:
                name: or
                args: 
                  - 
                    LutExpr:
                      name: isLess
                      args: 
                        - 
                          SliceExpr:
                            source: 'cmp1'
                            var: cmp1
                            offset: 0
                            size: 1
                  - 
                    LutExpr:
                      name: and
                      args: 
                        - 
                          LutExpr:
                            name: isZero
                            args: 
                              - 
                                SliceExpr:
                                  source: 'cmp1'
                                  var: cmp1
                                  offset: 0
                                  size: 1
                        - 
                          SliceExpr:
                            source: 'posQuo'
                            var: posQuo
                            offset: 0
                            size: 1
      high:
        FuncExpr:
          source: 'add<Int>(rem0, div)'
          name: add_27
          args:
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div'
              var: div
              offset: 0
              size: 27
      neg2:
        FuncExpr:
          source: 'neg<Int>(high)'
          name: neg_27
          args:
          - 
            SliceExpr:
              source: 'high'
              var: high
              offset: 0
              size: 27
      cmp2:
        FuncExpr:
          source: 'cmp<Int>(neg2, rem0)'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'neg2'
              var: neg2
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 27
      negRem:
        LutExpr:
          name: isNegative
          args: 
            - 
              SliceExpr:
                source: 'remSign'
                var: remSign
                offset: 0
                size: 1
      negQuo:
        LutExpr:
          name: isNegative
          args: 
            - 
              SliceExpr:
                source: 'quoSign'
                var: quoSign
                offset: 0
                size: 1
      test2:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'negRem'
                var: negRem
                offset: 0
                size: 1
            - 
              LutExpr:
                name: or
                args: 
                  - 
                    LutExpr:
                      name: isGreater
                      args: 
                        - 
                          SliceExpr:
                            source: 'cmp2'
                            var: cmp2
                            offset: 0
                            size: 1
                  - 
                    LutExpr:
                      name: and
                      args: 
                        - 
                          LutExpr:
                            name: isEqual
                            args: 
                              - 
                                SliceExpr:
                                  source: 'cmp2'
                                  var: cmp2
                                  offset: 0
                                  size: 1
                        - 
                          SliceExpr:
                            source: 'negQuo'
                            var: negQuo
                            offset: 0
                            size: 1
      quorem1:
        TypeExpr:
          source: 'T2{ /   quotient = incr<Int>(quo0) /   remainder = low / }'
          type: 
            ConstTypeName:
              typeName: T2
              size: 54
              fields:
                quotient: 
                  size: '27'
                  offset: '0'
                remainder: 
                  size: '27'
                  offset: '27'
          fieldValues: 
            quotient:
              FuncExpr:
                source: 'incr<Int>(quo0)'
                name: incr_27
                args:
                - 
                  SliceExpr:
                    source: 'quo0'
                    var: quo0
                    offset: 0
                    size: 27
            remainder:
              SliceExpr:
                source: 'low'
                var: low
                offset: 0
                size: 27
      quorem2:
        TypeExpr:
          source: 'T2{ /   quotient = decr<Int>(quo0) /   remainder = high / }'
          type: 
            ConstTypeName:
              typeName: T2
              size: 54
              fields:
                quotient: 
                  size: '27'
                  offset: '0'
                remainder: 
                  size: '27'
                  offset: '27'
          fieldValues: 
            quotient:
              FuncExpr:
                source: 'decr<Int>(quo0)'
                name: decr_27
                args:
                - 
                  SliceExpr:
                    source: 'quo0'
                    var: quo0
                    offset: 0
                    size: 27
            remainder:
              SliceExpr:
                source: 'high'
                var: high
                offset: 0
                size: 27
    return: 
    # test1 ? quorem1 : test2 ? quorem2 : quorem
      CondExpr:
        source: 'test1 ? quorem1 : test2 ? quorem2 : quorem'
        if: 
          SliceExpr:
            source: 'test1'
            var: test1
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'quorem1'
            var: quorem1
            offset: 0
            size: 54
        else:
          CondExpr:
            source: 'test2 ? quorem2 : quorem'
            if: 
              SliceExpr:
                source: 'test2'
                var: test2
                offset: 0
                size: 1
            then: 
              SliceExpr:
                source: 'quorem2'
                var: quorem2
                offset: 0
                size: 54
            else:
              SliceExpr:
                source: 'quorem'
                var: quorem
                offset: 0
                size: 54
# 
# func T2 fixSign<Int>(Int lhs, Int rhs, Int quo, Int rem) {
#   lhsSign = sign<Int>(lhs)
#   rhsSign = sign<Int>(rhs)
#   negRem = isNegative[lhsSign]
#   negQuo = xor[negRem, isNegative[rhsSign]]
#   quo1 = negQuo ? neg<Int>(quo) : quo
#   rem1 = negRem ? neg<Int>(rem) : rem
#   return T2{
#     quotient = quo1
#     remainder = rem1
#   }
# }
  fixSign_27:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: quo
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rem
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      lhsSign:
        FuncExpr:
          source: 'sign<Int>(lhs)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
      rhsSign:
        FuncExpr:
          source: 'sign<Int>(rhs)'
          name: sign_27
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
      negRem:
        LutExpr:
          name: isNegative
          args: 
            - 
              SliceExpr:
                source: 'lhsSign'
                var: lhsSign
                offset: 0
                size: 1
      negQuo:
        LutExpr:
          name: xor
          args: 
            - 
              SliceExpr:
                source: 'negRem'
                var: negRem
                offset: 0
                size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'rhsSign'
                      var: rhsSign
                      offset: 0
                      size: 1
      quo1:
        CondExpr:
          source: 'negQuo ? neg<Int>(quo) : quo'
          if: 
            SliceExpr:
              source: 'negQuo'
              var: negQuo
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'neg<Int>(quo)'
              name: neg_27
              args:
              - 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 27
          else:
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 27
      rem1:
        CondExpr:
          source: 'negRem ? neg<Int>(rem) : rem'
          if: 
            SliceExpr:
              source: 'negRem'
              var: negRem
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'neg<Int>(rem)'
              name: neg_27
              args:
              - 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 27
          else:
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 27
    return: 
    # T2{
    #   quotient = quo1
    #   remainder = rem1
    # }
      TypeExpr:
        source: 'T2{ /   quotient = quo1 /   remainder = rem1 / }'
        type: 
          ConstTypeName:
            typeName: T2
            size: 54
            fields:
              quotient: 
                size: '27'
                offset: '0'
              remainder: 
                size: '27'
                offset: '27'
        fieldValues: 
          quotient:
            SliceExpr:
              source: 'quo1'
              var: quo1
              offset: 0
              size: 27
          remainder:
            SliceExpr:
              source: 'rem1'
              var: rem1
              offset: 0
              size: 27
# 
# func Int abs<Int>(Int val) {
#   return isNegative[sign<Int>(val)] ? neg<Int>(val) : val
# }
  abs_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # isNegative[sign<Int>(val)] ? neg<Int>(val) : val
      CondExpr:
        source: 'isNegative[sign<Int>(val)] ? neg<Int>(val) : val'
        if: 
          LutExpr:
            name: isNegative
            args: 
              - 
                FuncExpr:
                  source: 'sign<Int>(val)'
                  name: sign_27
                  args:
                  - 
                    SliceExpr:
                      source: 'val'
                      var: val
                      offset: 0
                      size: 27
        then: 
          FuncExpr:
            source: 'neg<Int>(val)'
            name: neg_27
            args:
            - 
              SliceExpr:
                source: 'val'
                var: val
                offset: 0
                size: 27
        else:
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 27
# 
# func T2 as<T2>(T2 val) {
#   return val
# }
  as_54:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: val
        size: 54
        type: 
          ConstTypeName:
            typeName: T2
            size: 54
            fields:
              quotient: 
                size: '27'
                offset: '0'
              remainder: 
                size: '27'
                offset: '27'
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 54
# 
# func T2 rshift<T2>(T2 val) {
#   return 0 & val[0 : T2 - 1]
# }
  rshift_54:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 54
        fields:
          quotient: 
            size: '27'
            offset: '0'
          remainder: 
            size: '27'
            offset: '27'
    params:
      - 
        argName: val
        size: 54
        type: 
          ConstTypeName:
            typeName: T2
            size: 54
            fields:
              quotient: 
                size: '27'
                offset: '0'
              remainder: 
                size: '27'
                offset: '27'
    return: 
    # 0 & val[0 : T2 - 1]
      ConcatExpr:
        source: '0 & val[0 : T2 - 1]'
        lhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
        rhs: 
          SliceExpr:
            source: 'val[0 : T2 - 1]'
            var: val
            offset: 0
            size: 53
            start:
              ConstNumber:
                value: 0
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: T2
                    size: 54
                    fields:
                      quotient: 
                        size: '27'
                        offset: '0'
                      remainder: 
                        size: '27'
                        offset: '27'
                rhs: 
                  ConstNumber:
                    value: 1
# 
# func Int incr<Int>(Int val) {
#   halfSum = halfAdd<Int>(val, 1)
#   return halfSum.value
# }
  incr_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      halfSum:
        FuncExpr:
          source: 'halfAdd<Int>(val, 1)'
          name: halfAdd_27
          args:
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '1'
                trits: '1'
                trytes: 'A'
    return: 
    # halfSum.value
      SliceExpr:
        source: 'halfSum.value'
        var: halfSum
        offset: 0
        size: 27
        fields: 
          - value
# 
# func Int decr<Int>(Int val) {
#   halfSum = halfAdd<Int>(val, -)
#   return halfSum.value
# }
  decr_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      halfSum:
        FuncExpr:
          source: 'halfAdd<Int>(val, -)'
          name: halfAdd_27
          args:
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '-'
                trits: '-'
                trytes: 'Z'
    return: 
    # halfSum.value
      SliceExpr:
        source: 'halfSum.value'
        var: halfSum
        offset: 0
        size: 27
        fields: 
          - value
# 
# func Int rshift<Int>(Int val) {
#   return 0 & val[0 : Int - 1]
# }
  rshift_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # 0 & val[0 : Int - 1]
      ConcatExpr:
        source: '0 & val[0 : Int - 1]'
        lhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
        rhs: 
          SliceExpr:
            source: 'val[0 : Int - 1]'
            var: val
            offset: 0
            size: 26
            start:
              ConstNumber:
                value: 0
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Int
                    size: 27
                rhs: 
                  ConstNumber:
                    value: 1
# 
# func Bool hasDivisor<Huge>(Huge n, Huge from, Huge to) {
#   sqrfrom = mul<Huge>(from, from)
#   compare = cmp<Huge>(sqrfrom, n)
#   return isZero[compare] ? true : notGreater[compare] ? hasDivisorCheckAll<Huge>(n, from, to) : false
# }
  hasDivisor_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: from
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: to
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      sqrfrom:
        FuncExpr:
          source: 'mul<Huge>(from, from)'
          name: mul_81
          args:
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 81
      compare:
        FuncExpr:
          source: 'cmp<Huge>(sqrfrom, n)'
          name: cmp_81
          args:
          - 
            SliceExpr:
              source: 'sqrfrom'
              var: sqrfrom
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 81
    return: 
    # isZero[compare] ? true : notGreater[compare] ? hasDivisorCheckAll<Huge>(n, from, to) : false
      CondExpr:
        source: 'isZero[compare] ? true : notGreater[compare] ? hasDivisorCheckAll<Huge>(n, from, to) : false'
        if: 
          LutExpr:
            name: isZero
            args: 
              - 
                SliceExpr:
                  source: 'compare'
                  var: compare
                  offset: 0
                  size: 1
        then: 
          ValueExpr:
              value: '1'
              trits: '1'
              trytes: 'A'
        else:
          CondExpr:
            source: 'notGreater[compare] ? hasDivisorCheckAll<Huge>(n, from, to) : false'
            if: 
              LutExpr:
                name: notGreater
                args: 
                  - 
                    SliceExpr:
                      source: 'compare'
                      var: compare
                      offset: 0
                      size: 1
            then: 
              FuncExpr:
                source: 'hasDivisorCheckAll<Huge>(n, from, to)'
                name: hasDivisorCheckAll_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'from'
                    var: from
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'to'
                    var: to
                    offset: 0
                    size: 81
            else:
              ValueExpr:
                  value: '0'
                  trits: '0'
                  trytes: '9'
# 
# func Bool isDivisor<Huge>(Huge n, Huge divisor) {
#   t = divMod<Huge>(n, divisor)
#   return equal<Huge>(t.remainder, 0)
# }
  isDivisor_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: divisor
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      t:
        FuncExpr:
          source: 'divMod<Huge>(n, divisor)'
          name: divMod_81
          args:
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'divisor'
              var: divisor
              offset: 0
              size: 81
    return: 
    # equal<Huge>(t.remainder, 0)
      FuncExpr:
        source: 'equal<Huge>(t.remainder, 0)'
        name: equal_81
        args:
        - 
          SliceExpr:
            source: 't.remainder'
            var: t
            offset: 81
            size: 81
            fields: 
              - remainder
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999'
# 
# func Bool hasDivisorCheckAll<Huge>(Huge n, Huge from, Huge to) {
#   len = sub<Huge>(to, from)
#   return equal<Huge>(len, 0) ? isDivisor<Huge>(n, from) : equal<Huge>(len, 1) ? (isDivisor<Huge>(n, from) ? 1 : isDivisor<Huge>(n, to)) : lookDeeperForDivisors<Huge>(n, from, to)
# }
  hasDivisorCheckAll_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: from
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: to
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      len:
        FuncExpr:
          source: 'sub<Huge>(to, from)'
          name: sub_81
          args:
          - 
            SliceExpr:
              source: 'to'
              var: to
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 81
    return: 
    # equal<Huge>(len, 0) ? isDivisor<Huge>(n, from) : equal<Huge>(len, 1) ? (isDivisor<Huge>(n, from) ? 1 : isDivisor<Huge>(n, to)) : lookDeeperForDivisors<Huge>(n, from, to)
      CondExpr:
        source: 'equal<Huge>(len, 0) ? isDivisor<Huge>(n, from) : equal<Huge>(len, 1) ? (isDivisor<Huge>(n, from) ? 1 : isDivisor<Huge>(n, to)) : lookDeeperForDivisors<Huge>(n, from, to)'
        if: 
          FuncExpr:
            source: 'equal<Huge>(len, 0)'
            name: equal_81
            args:
            - 
              SliceExpr:
                source: 'len'
                var: len
                offset: 0
                size: 81
            - 
              ValueExpr:
                  value: '0'
                  trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                  trytes: '999999999999999999999999999'
        then: 
          FuncExpr:
            source: 'isDivisor<Huge>(n, from)'
            name: isDivisor_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'from'
                var: from
                offset: 0
                size: 81
        else:
          CondExpr:
            source: 'equal<Huge>(len, 1) ? (isDivisor<Huge>(n, from) ? 1 : isDivisor<Huge>(n, to)) : lookDeeperForDivisors<Huge>(n, from, to)'
            if: 
              FuncExpr:
                source: 'equal<Huge>(len, 1)'
                name: equal_81
                args:
                - 
                  SliceExpr:
                    source: 'len'
                    var: len
                    offset: 0
                    size: 81
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                      trytes: 'A99999999999999999999999999'
            then: 
              CondExpr:
                source: 'isDivisor<Huge>(n, from) ? 1 : isDivisor<Huge>(n, to)'
                if: 
                  FuncExpr:
                    source: 'isDivisor<Huge>(n, from)'
                    name: isDivisor_81
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 81
                    - 
                      SliceExpr:
                        source: 'from'
                        var: from
                        offset: 0
                        size: 81
                then: 
                  ValueExpr:
                      value: '1'
                      trits: '1'
                      trytes: 'A'
                else:
                  FuncExpr:
                    source: 'isDivisor<Huge>(n, to)'
                    name: isDivisor_81
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 81
                    - 
                      SliceExpr:
                        source: 'to'
                        var: to
                        offset: 0
                        size: 81
            else:
              FuncExpr:
                source: 'lookDeeperForDivisors<Huge>(n, from, to)'
                name: lookDeeperForDivisors_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'from'
                    var: from
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'to'
                    var: to
                    offset: 0
                    size: 81
# 
# func Bool lookDeeperForDivisors<Huge>(Huge n, Huge from, Huge to) {
#   div3 = lshift<Huge>(sub<Huge>(to, from))
#   i1 = add<Huge>(from, div3)
#   i2 = add<Huge>(i1, div3)
#   return hasDivisor<Huge>(n, from, i1) ? true : hasDivisor<Huge>(n, i1, i2) ? hasDivisor<Huge>(n, i2, to) : false
# }
  lookDeeperForDivisors_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: from
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: to
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      div3:
        FuncExpr:
          source: 'lshift<Huge>(sub<Huge>(to, from))'
          name: lshift_81
          args:
          - 
            FuncExpr:
              source: 'sub<Huge>(to, from)'
              name: sub_81
              args:
              - 
                SliceExpr:
                  source: 'to'
                  var: to
                  offset: 0
                  size: 81
              - 
                SliceExpr:
                  source: 'from'
                  var: from
                  offset: 0
                  size: 81
      i1:
        FuncExpr:
          source: 'add<Huge>(from, div3)'
          name: add_81
          args:
          - 
            SliceExpr:
              source: 'from'
              var: from
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 81
      i2:
        FuncExpr:
          source: 'add<Huge>(i1, div3)'
          name: add_81
          args:
          - 
            SliceExpr:
              source: 'i1'
              var: i1
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 81
    return: 
    # hasDivisor<Huge>(n, from, i1) ? true : hasDivisor<Huge>(n, i1, i2) ? hasDivisor<Huge>(n, i2, to) : false
      CondExpr:
        source: 'hasDivisor<Huge>(n, from, i1) ? true : hasDivisor<Huge>(n, i1, i2) ? hasDivisor<Huge>(n, i2, to) : false'
        if: 
          FuncExpr:
            source: 'hasDivisor<Huge>(n, from, i1)'
            name: hasDivisor_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'from'
                var: from
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'i1'
                var: i1
                offset: 0
                size: 81
        then: 
          ValueExpr:
              value: '1'
              trits: '1'
              trytes: 'A'
        else:
          CondExpr:
            source: 'hasDivisor<Huge>(n, i1, i2) ? hasDivisor<Huge>(n, i2, to) : false'
            if: 
              FuncExpr:
                source: 'hasDivisor<Huge>(n, i1, i2)'
                name: hasDivisor_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'i1'
                    var: i1
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'i2'
                    var: i2
                    offset: 0
                    size: 81
            then: 
              FuncExpr:
                source: 'hasDivisor<Huge>(n, i2, to)'
                name: hasDivisor_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'i2'
                    var: i2
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'to'
                    var: to
                    offset: 0
                    size: 81
            else:
              ValueExpr:
                  value: '0'
                  trits: '0'
                  trytes: '9'
# 
# func Bool isPrime<Huge>(Huge n) {
#   return or[equal<Huge>(n, 1), or[equal<Huge>(n, 2), equal<Huge>(n, 3)]] ? 1 : not[hasDivisor<Huge>(n, 2, sub<Huge>(n, 1))]
# }
  isPrime_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # or[equal<Huge>(n, 1), or[equal<Huge>(n, 2), equal<Huge>(n, 3)]] ? 1 : not[hasDivisor<Huge>(n, 2, sub<Huge>(n, 1))]
      CondExpr:
        source: 'or[equal<Huge>(n, 1), or[equal<Huge>(n, 2), equal<Huge>(n, 3)]] ? 1 : not[hasDivisor<Huge>(n, 2, sub<Huge>(n, 1))]'
        if: 
          LutExpr:
            name: or
            args: 
              - 
                FuncExpr:
                  source: 'equal<Huge>(n, 1)'
                  name: equal_81
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 81
                  - 
                    ValueExpr:
                        value: '1'
                        trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                        trytes: 'A99999999999999999999999999'
              - 
                LutExpr:
                  name: or
                  args: 
                    - 
                      FuncExpr:
                        source: 'equal<Huge>(n, 2)'
                        name: equal_81
                        args:
                        - 
                          SliceExpr:
                            source: 'n'
                            var: n
                            offset: 0
                            size: 81
                        - 
                          ValueExpr:
                              value: '2'
                              trits: '-10000000000000000000000000000000000000000000000000000000000000000000000000000000'
                              trytes: 'B99999999999999999999999999'
                    - 
                      FuncExpr:
                        source: 'equal<Huge>(n, 3)'
                        name: equal_81
                        args:
                        - 
                          SliceExpr:
                            source: 'n'
                            var: n
                            offset: 0
                            size: 81
                        - 
                          ValueExpr:
                              value: '3'
                              trits: '010000000000000000000000000000000000000000000000000000000000000000000000000000000'
                              trytes: 'C99999999999999999999999999'
        then: 
          ValueExpr:
              value: '1'
              trits: '1'
              trytes: 'A'
        else:
          LutExpr:
            name: not
            args: 
              - 
                FuncExpr:
                  source: 'hasDivisor<Huge>(n, 2, sub<Huge>(n, 1))'
                  name: hasDivisor_81
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 81
                  - 
                    ValueExpr:
                        value: '2'
                        trits: '-10000000000000000000000000000000000000000000000000000000000000000000000000000000'
                        trytes: 'B99999999999999999999999999'
                  - 
                    FuncExpr:
                      source: 'sub<Huge>(n, 1)'
                      name: sub_81
                      args:
                      - 
                        SliceExpr:
                          source: 'n'
                          var: n
                          offset: 0
                          size: 81
                      - 
                        ValueExpr:
                            value: '1'
                            trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                            trytes: 'A99999999999999999999999999'
# 
# func Huge primesList<Huge>(Huge from, Huge to) {
#   dummy = (isPrime<Huge>(from) ? print<Huge>(from) : as<Huge>(0))
#   return equal<Huge>(from, to) ? dummy : primesList<Huge>(incr<Huge>(from), to)
# }
  primesList_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: from
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: to
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      dummy:
        CondExpr:
          source: 'isPrime<Huge>(from) ? print<Huge>(from) : as<Huge>(0)'
          if: 
            FuncExpr:
              source: 'isPrime<Huge>(from)'
              name: isPrime_81
              args:
              - 
                SliceExpr:
                  source: 'from'
                  var: from
                  offset: 0
                  size: 81
          then: 
            FuncExpr:
              source: 'print<Huge>(from)'
              name: print_81
              args:
              - 
                SliceExpr:
                  source: 'from'
                  var: from
                  offset: 0
                  size: 81
          else:
            FuncExpr:
              source: 'as<Huge>(0)'
              name: as_81
              args:
              - 
                ValueExpr:
                    value: '0'
                    trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                    trytes: '999999999999999999999999999'
    return: 
    # equal<Huge>(from, to) ? dummy : primesList<Huge>(incr<Huge>(from), to)
      CondExpr:
        source: 'equal<Huge>(from, to) ? dummy : primesList<Huge>(incr<Huge>(from), to)'
        if: 
          FuncExpr:
            source: 'equal<Huge>(from, to)'
            name: equal_81
            args:
            - 
              SliceExpr:
                source: 'from'
                var: from
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'to'
                var: to
                offset: 0
                size: 81
        then: 
          SliceExpr:
            source: 'dummy'
            var: dummy
            offset: 0
            size: 81
        else:
          FuncExpr:
            source: 'primesList<Huge>(incr<Huge>(from), to)'
            name: primesList_81
            args:
            - 
              FuncExpr:
                source: 'incr<Huge>(from)'
                name: incr_81
                args:
                - 
                  SliceExpr:
                    source: 'from'
                    var: from
                    offset: 0
                    size: 81
            - 
              SliceExpr:
                source: 'to'
                var: to
                offset: 0
                size: 81
# 
# func Bool equal<Huge>(Huge lhs, Huge rhs) {
#   val0 = equal<A>(lhs[0 : A], rhs[0 : A])
#   val1 = equal<B>(lhs[A : B], rhs[A : B])
#   val2 = equal<C>(lhs[A + B : C], rhs[A + B : C])
#   return and3[val0, val1, val2]
# }
  equal_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      val0:
        FuncExpr:
          source: 'equal<A>(lhs[0 : A], rhs[0 : A])'
          name: equal_27
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
      val1:
        FuncExpr:
          source: 'equal<B>(lhs[A : B], rhs[A : B])'
          name: equal_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
      val2:
        FuncExpr:
          source: 'equal<C>(lhs[A + B : C], rhs[A + B : C])'
          name: equal_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
    return: 
    # and3[val0, val1, val2]
      LutExpr:
        name: and3
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Trit cmp<Huge>(Huge lhs, Huge rhs) {
#   val0 = cmp<A>(lhs[0 : A], rhs[0 : A])
#   val1 = cmp<B>(lhs[A : B], rhs[A : B])
#   val2 = cmp<C>(lhs[A + B : C], rhs[A + B : C])
#   return sign[val0, val1, val2]
# }
  cmp_81:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      val0:
        FuncExpr:
          source: 'cmp<A>(lhs[0 : A], rhs[0 : A])'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
      val1:
        FuncExpr:
          source: 'cmp<B>(lhs[A : B], rhs[A : B])'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
      val2:
        FuncExpr:
          source: 'cmp<C>(lhs[A + B : C], rhs[A + B : C])'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A + B : C]'
              var: lhs
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A + B : C]'
              var: rhs
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
    return: 
    # sign[val0, val1, val2]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Huge sub<Huge>(Huge lhs, Huge rhs) {
#   sum = fullAdd<Huge>(lhs, neg<Huge>(rhs), 0)
#   return sum.value
# }
  sub_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      sum:
        FuncExpr:
          source: 'fullAdd<Huge>(lhs, neg<Huge>(rhs), 0)'
          name: fullAdd_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
          - 
            FuncExpr:
              source: 'neg<Huge>(rhs)'
              name: neg_81
              args:
              - 
                SliceExpr:
                  source: 'rhs'
                  var: rhs
                  offset: 0
                  size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
    return: 
    # sum.value
      SliceExpr:
        source: 'sum.value'
        var: sum
        offset: 0
        size: 81
        fields: 
          - value
# 
# func Huge neg<Huge>(Huge val) {
#   val0 = neg<A>(val[0 : A])
#   val1 = neg<B>(val[A : B])
#   val2 = neg<C>(val[A + B : C])
#   return val0 & val1 & val2
# }
  neg_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      val0:
        FuncExpr:
          source: 'neg<A>(val[0 : A])'
          name: neg_27
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
      val1:
        FuncExpr:
          source: 'neg<B>(val[A : B])'
          name: neg_27
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
      val2:
        FuncExpr:
          source: 'neg<C>(val[A + B : C])'
          name: neg_27
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 54
              size: 27
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 27
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 27
              end:
                ConstTypeName:
                  typeName: C
                  size: 27
    return: 
    # val0 & val1 & val2
      ConcatExpr:
        source: 'val0 & val1 & val2'
        lhs: 
          ConcatExpr:
            source: 'val0 & val1'
            lhs: 
              SliceExpr:
                source: 'val0'
                var: val0
                offset: 0
                size: 27
            rhs: 
              SliceExpr:
                source: 'val1'
                var: val1
                offset: 0
                size: 27
        rhs: 
          SliceExpr:
            source: 'val2'
            var: val2
            offset: 0
            size: 27
# 
# func T2 divMod<Huge>(Huge lhs, Huge rhs) {
#   absLhs = abs<Huge>(lhs)
#   absRhs = abs<Huge>(rhs)
#   quorem = roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   fix = isNegative[sign<Huge>(rem)]
#   quo0 = fix ? decr<Huge>(quo) : quo
#   rem0 = fix ? add<Huge>(rem, absRhs) : rem
#   return fixSign<Huge>(lhs, rhs, quo0, rem0)
# }
  divMod_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Huge>(lhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      absRhs:
        FuncExpr:
          source: 'abs<Huge>(rhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_81
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: '999999999999999999999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: 'A99999999999999999999999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 81
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 81
          size: 81
          fields: 
            - remainder
      fix:
        LutExpr:
          name: isNegative
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(rem)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'rem'
                    var: rem
                    offset: 0
                    size: 81
      quo0:
        CondExpr:
          source: 'fix ? decr<Huge>(quo) : quo'
          if: 
            SliceExpr:
              source: 'fix'
              var: fix
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'decr<Huge>(quo)'
              name: decr_81
              args:
              - 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 81
          else:
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 81
      rem0:
        CondExpr:
          source: 'fix ? add<Huge>(rem, absRhs) : rem'
          if: 
            SliceExpr:
              source: 'fix'
              var: fix
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'add<Huge>(rem, absRhs)'
              name: add_81
              args:
              - 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 81
              - 
                SliceExpr:
                  source: 'absRhs'
                  var: absRhs
                  offset: 0
                  size: 81
          else:
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
    return: 
    # fixSign<Huge>(lhs, rhs, quo0, rem0)
      FuncExpr:
        source: 'fixSign<Huge>(lhs, rhs, quo0, rem0)'
        name: fixSign_81
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'quo0'
            var: quo0
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rem0'
            var: rem0
            offset: 0
            size: 81
# 
# func T2 ceilDivMod<Huge>(Huge lhs, Huge rhs) {
#   absLhs = abs<Huge>(lhs)
#   absRhs = abs<Huge>(rhs)
#   quorem = roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   lhsSign = sign<Huge>(lhs)
#   rhsSign = sign<Huge>(rhs)
#   remSign = sign<Huge>(rem)
#   neg = xor[isNegative[lhsSign], isNegative[rhsSign]]
#   up = and[not[neg], isPositive[remSign]]
#   down = and[neg, isNegative[remSign]]
#   none = nor[up, down]
#   quoN0 = none ? quo : null
#   quoN1 = incr<Huge>(up ? quo : null)
#   quoN2 = decr<Huge>(down ? quo : null)
#   quo0 = quoN0 | quoN1 | quoN2
#   remN0 = none ? rem : null
#   remN1 = sub<Huge>(up ? rem : null, absRhs)
#   remN2 = add<Huge>(down ? rem : null, absRhs)
#   rem0 = remN0 | remN1 | remN2
#   return fixSign<Huge>(lhs, rhs, quo0, rem0)
# }
  ceilDivMod_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Huge>(lhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      absRhs:
        FuncExpr:
          source: 'abs<Huge>(rhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_81
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: '999999999999999999999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: 'A99999999999999999999999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 81
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 81
          size: 81
          fields: 
            - remainder
      lhsSign:
        FuncExpr:
          source: 'sign<Huge>(lhs)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      rhsSign:
        FuncExpr:
          source: 'sign<Huge>(rhs)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      remSign:
        FuncExpr:
          source: 'sign<Huge>(rem)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
      neg:
        LutExpr:
          name: xor
          args: 
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'lhsSign'
                      var: lhsSign
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'rhsSign'
                      var: rhsSign
                      offset: 0
                      size: 1
      up:
        LutExpr:
          name: and
          args: 
            - 
              LutExpr:
                name: not
                args: 
                  - 
                    SliceExpr:
                      source: 'neg'
                      var: neg
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isPositive
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      down:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'neg'
                var: neg
                offset: 0
                size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      none:
        LutExpr:
          name: nor
          args: 
            - 
              SliceExpr:
                source: 'up'
                var: up
                offset: 0
                size: 1
            - 
              SliceExpr:
                source: 'down'
                var: down
                offset: 0
                size: 1
      quoN0:
        CondExpr:
          source: 'none ? quo : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 81
          else:
            NullExpr: ''
      quoN1:
        FuncExpr:
          source: 'incr<Huge>(up ? quo : null)'
          name: incr_81
          args:
          - 
            CondExpr:
              source: 'up ? quo : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
      quoN2:
        FuncExpr:
          source: 'decr<Huge>(down ? quo : null)'
          name: decr_81
          args:
          - 
            CondExpr:
              source: 'down ? quo : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
      quo0:
        MergeExpr:
          source: 'quoN0 | quoN1 | quoN2'
          lhs: 
            MergeExpr:
              source: 'quoN0 | quoN1'
              lhs: 
                SliceExpr:
                  source: 'quoN0'
                  var: quoN0
                  offset: 0
                  size: 81
              rhs: 
                SliceExpr:
                  source: 'quoN1'
                  var: quoN1
                  offset: 0
                  size: 81
          rhs: 
            SliceExpr:
              source: 'quoN2'
              var: quoN2
              offset: 0
              size: 81
      remN0:
        CondExpr:
          source: 'none ? rem : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
          else:
            NullExpr: ''
      remN1:
        FuncExpr:
          source: 'sub<Huge>(up ? rem : null, absRhs)'
          name: sub_81
          args:
          - 
            CondExpr:
              source: 'up ? rem : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
      remN2:
        FuncExpr:
          source: 'add<Huge>(down ? rem : null, absRhs)'
          name: add_81
          args:
          - 
            CondExpr:
              source: 'down ? rem : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
      rem0:
        MergeExpr:
          source: 'remN0 | remN1 | remN2'
          lhs: 
            MergeExpr:
              source: 'remN0 | remN1'
              lhs: 
                SliceExpr:
                  source: 'remN0'
                  var: remN0
                  offset: 0
                  size: 81
              rhs: 
                SliceExpr:
                  source: 'remN1'
                  var: remN1
                  offset: 0
                  size: 81
          rhs: 
            SliceExpr:
              source: 'remN2'
              var: remN2
              offset: 0
              size: 81
    return: 
    # fixSign<Huge>(lhs, rhs, quo0, rem0)
      FuncExpr:
        source: 'fixSign<Huge>(lhs, rhs, quo0, rem0)'
        name: fixSign_81
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'quo0'
            var: quo0
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rem0'
            var: rem0
            offset: 0
            size: 81
# 
# func T2 floorDivMod<Huge>(Huge lhs, Huge rhs) {
#   absLhs = abs<Huge>(lhs)
#   absRhs = abs<Huge>(rhs)
#   quorem = roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   lhsSign = sign<Huge>(lhs)
#   rhsSign = sign<Huge>(rhs)
#   remSign = sign<Huge>(rem)
#   neg = xor[isNegative[lhsSign], isNegative[rhsSign]]
#   down = and[not[neg], isNegative[remSign]]
#   up = and[neg, isPositive[remSign]]
#   none = nor[up, down]
#   quoN0 = none ? quo : null
#   quoN1 = incr<Huge>(up ? quo : null)
#   quoN2 = decr<Huge>(down ? quo : null)
#   quo0 = quoN0 | quoN1 | quoN2
#   remN0 = none ? rem : null
#   remN1 = sub<Huge>(up ? rem : null, absRhs)
#   remN2 = add<Huge>(down ? rem : null, absRhs)
#   rem0 = remN0 | remN1 | remN2
#   return fixSign<Huge>(lhs, rhs, quo0, rem0)
# }
  floorDivMod_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Huge>(lhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      absRhs:
        FuncExpr:
          source: 'abs<Huge>(rhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_81
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: '999999999999999999999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: 'A99999999999999999999999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 81
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 81
          size: 81
          fields: 
            - remainder
      lhsSign:
        FuncExpr:
          source: 'sign<Huge>(lhs)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      rhsSign:
        FuncExpr:
          source: 'sign<Huge>(rhs)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      remSign:
        FuncExpr:
          source: 'sign<Huge>(rem)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
      neg:
        LutExpr:
          name: xor
          args: 
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'lhsSign'
                      var: lhsSign
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'rhsSign'
                      var: rhsSign
                      offset: 0
                      size: 1
      down:
        LutExpr:
          name: and
          args: 
            - 
              LutExpr:
                name: not
                args: 
                  - 
                    SliceExpr:
                      source: 'neg'
                      var: neg
                      offset: 0
                      size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      up:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'neg'
                var: neg
                offset: 0
                size: 1
            - 
              LutExpr:
                name: isPositive
                args: 
                  - 
                    SliceExpr:
                      source: 'remSign'
                      var: remSign
                      offset: 0
                      size: 1
      none:
        LutExpr:
          name: nor
          args: 
            - 
              SliceExpr:
                source: 'up'
                var: up
                offset: 0
                size: 1
            - 
              SliceExpr:
                source: 'down'
                var: down
                offset: 0
                size: 1
      quoN0:
        CondExpr:
          source: 'none ? quo : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 81
          else:
            NullExpr: ''
      quoN1:
        FuncExpr:
          source: 'incr<Huge>(up ? quo : null)'
          name: incr_81
          args:
          - 
            CondExpr:
              source: 'up ? quo : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
      quoN2:
        FuncExpr:
          source: 'decr<Huge>(down ? quo : null)'
          name: decr_81
          args:
          - 
            CondExpr:
              source: 'down ? quo : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
      quo0:
        MergeExpr:
          source: 'quoN0 | quoN1 | quoN2'
          lhs: 
            MergeExpr:
              source: 'quoN0 | quoN1'
              lhs: 
                SliceExpr:
                  source: 'quoN0'
                  var: quoN0
                  offset: 0
                  size: 81
              rhs: 
                SliceExpr:
                  source: 'quoN1'
                  var: quoN1
                  offset: 0
                  size: 81
          rhs: 
            SliceExpr:
              source: 'quoN2'
              var: quoN2
              offset: 0
              size: 81
      remN0:
        CondExpr:
          source: 'none ? rem : null'
          if: 
            SliceExpr:
              source: 'none'
              var: none
              offset: 0
              size: 1
          then: 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
          else:
            NullExpr: ''
      remN1:
        FuncExpr:
          source: 'sub<Huge>(up ? rem : null, absRhs)'
          name: sub_81
          args:
          - 
            CondExpr:
              source: 'up ? rem : null'
              if: 
                SliceExpr:
                  source: 'up'
                  var: up
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
      remN2:
        FuncExpr:
          source: 'add<Huge>(down ? rem : null, absRhs)'
          name: add_81
          args:
          - 
            CondExpr:
              source: 'down ? rem : null'
              if: 
                SliceExpr:
                  source: 'down'
                  var: down
                  offset: 0
                  size: 1
              then: 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 81
              else:
                NullExpr: ''
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
      rem0:
        MergeExpr:
          source: 'remN0 | remN1 | remN2'
          lhs: 
            MergeExpr:
              source: 'remN0 | remN1'
              lhs: 
                SliceExpr:
                  source: 'remN0'
                  var: remN0
                  offset: 0
                  size: 81
              rhs: 
                SliceExpr:
                  source: 'remN1'
                  var: remN1
                  offset: 0
                  size: 81
          rhs: 
            SliceExpr:
              source: 'remN2'
              var: remN2
              offset: 0
              size: 81
    return: 
    # fixSign<Huge>(lhs, rhs, quo0, rem0)
      FuncExpr:
        source: 'fixSign<Huge>(lhs, rhs, quo0, rem0)'
        name: fixSign_81
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'quo0'
            var: quo0
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rem0'
            var: rem0
            offset: 0
            size: 81
# 
# func T2 roundDivMod<Huge>(Huge lhs, Huge rhs) {
#   absLhs = abs<Huge>(lhs)
#   absRhs = abs<Huge>(rhs)
#   quorem = roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)
#   quo = quorem.quotient
#   rem = quorem.remainder
#   return fixSign<Huge>(lhs, rhs, quo, rem)
# }
  roundDivMod_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      absLhs:
        FuncExpr:
          source: 'abs<Huge>(lhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      absRhs:
        FuncExpr:
          source: 'abs<Huge>(rhs)'
          name: abs_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      quorem:
        FuncExpr:
          source: 'roundDivModLoop<Huge>(absLhs, 0, absRhs, 1)'
          name: roundDivModLoop_81
          args:
          - 
            SliceExpr:
              source: 'absLhs'
              var: absLhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '0'
                trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: '999999999999999999999999999'
          - 
            SliceExpr:
              source: 'absRhs'
              var: absRhs
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '1'
                trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                trytes: 'A99999999999999999999999999'
      quo:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 81
          fields: 
            - quotient
      rem:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 81
          size: 81
          fields: 
            - remainder
    return: 
    # fixSign<Huge>(lhs, rhs, quo, rem)
      FuncExpr:
        source: 'fixSign<Huge>(lhs, rhs, quo, rem)'
        name: fixSign_81
        args:
        - 
          SliceExpr:
            source: 'lhs'
            var: lhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rhs'
            var: rhs
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'quo'
            var: quo
            offset: 0
            size: 81
        - 
          SliceExpr:
            source: 'rem'
            var: rem
            offset: 0
            size: 81
# 
# func T2 roundDivModLoop<Huge>(Huge quo, Huge rem, Huge div, Huge shf) {
#   quorem = roundDivModPass<Huge>(quo, rem, div)
#   newShf = rshift<Huge>(shf)
#   zero = isZero[sign<Huge>(newShf)]
#   quo1 = quorem.quotient
#   rem1 = quorem.remainder
#   return zero ? quorem : roundDivModLoop<Huge>(quo1, rem1, div, newShf)
# }
  roundDivModLoop_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: quo
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rem
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: div
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: shf
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      quorem:
        FuncExpr:
          source: 'roundDivModPass<Huge>(quo, rem, div)'
          name: roundDivModPass_81
          args:
          - 
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div'
              var: div
              offset: 0
              size: 81
      newShf:
        FuncExpr:
          source: 'rshift<Huge>(shf)'
          name: rshift_81
          args:
          - 
            SliceExpr:
              source: 'shf'
              var: shf
              offset: 0
              size: 81
      zero:
        LutExpr:
          name: isZero
          args: 
            - 
              FuncExpr:
                source: 'sign<Huge>(newShf)'
                name: sign_81
                args:
                - 
                  SliceExpr:
                    source: 'newShf'
                    var: newShf
                    offset: 0
                    size: 81
      quo1:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 81
          fields: 
            - quotient
      rem1:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 81
          size: 81
          fields: 
            - remainder
    return: 
    # zero ? quorem : roundDivModLoop<Huge>(quo1, rem1, div, newShf)
      CondExpr:
        source: 'zero ? quorem : roundDivModLoop<Huge>(quo1, rem1, div, newShf)'
        if: 
          SliceExpr:
            source: 'zero'
            var: zero
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'quorem'
            var: quorem
            offset: 0
            size: 162
        else:
          FuncExpr:
            source: 'roundDivModLoop<Huge>(quo1, rem1, div, newShf)'
            name: roundDivModLoop_81
            args:
            - 
              SliceExpr:
                source: 'quo1'
                var: quo1
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'rem1'
                var: rem1
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'div'
                var: div
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'newShf'
                var: newShf
                offset: 0
                size: 81
# 
# func T2 roundDivModPass<Huge>(Huge quo, Huge rem, Huge div) {
#   quorem = as<T2>(rshift<T2>(quo & rem))
#   quo0 = quorem.quotient
#   rem0 = quorem.remainder
#   remSign = sign<Huge>(rem0)
#   quoSign = sign<Huge>(quo0)
#   low = sub<Huge>(rem0, div)
#   neg1 = neg<Huge>(low)
#   cmp1 = cmp<Huge>(neg1, rem0)
#   posRem = isPositive[remSign]
#   posQuo = isPositive[quoSign]
#   test1 = and[posRem, or[isLess[cmp1], and[isZero[cmp1], posQuo]]]
#   high = add<Huge>(rem0, div)
#   neg2 = neg<Huge>(high)
#   cmp2 = cmp<Huge>(neg2, rem0)
#   negRem = isNegative[remSign]
#   negQuo = isNegative[quoSign]
#   test2 = and[negRem, or[isGreater[cmp2], and[isEqual[cmp2], negQuo]]]
#   quorem1 = T2{
#     quotient = incr<Huge>(quo0)
#     remainder = low
#   }
#   quorem2 = T2{
#     quotient = decr<Huge>(quo0)
#     remainder = high
#   }
#   return test1 ? quorem1 : test2 ? quorem2 : quorem
# }
  roundDivModPass_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: quo
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rem
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: div
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      quorem:
        FuncExpr:
          source: 'as<T2>(rshift<T2>(quo & rem))'
          name: as_162
          args:
          - 
            FuncExpr:
              source: 'rshift<T2>(quo & rem)'
              name: rshift_162
              args:
              - 
                ConcatExpr:
                  source: 'quo & rem'
                  lhs: 
                    SliceExpr:
                      source: 'quo'
                      var: quo
                      offset: 0
                      size: 81
                  rhs: 
                    SliceExpr:
                      source: 'rem'
                      var: rem
                      offset: 0
                      size: 81
      quo0:
        SliceExpr:
          source: 'quorem.quotient'
          var: quorem
          offset: 0
          size: 81
          fields: 
            - quotient
      rem0:
        SliceExpr:
          source: 'quorem.remainder'
          var: quorem
          offset: 81
          size: 81
          fields: 
            - remainder
      remSign:
        FuncExpr:
          source: 'sign<Huge>(rem0)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 81
      quoSign:
        FuncExpr:
          source: 'sign<Huge>(quo0)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'quo0'
              var: quo0
              offset: 0
              size: 81
      low:
        FuncExpr:
          source: 'sub<Huge>(rem0, div)'
          name: sub_81
          args:
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div'
              var: div
              offset: 0
              size: 81
      neg1:
        FuncExpr:
          source: 'neg<Huge>(low)'
          name: neg_81
          args:
          - 
            SliceExpr:
              source: 'low'
              var: low
              offset: 0
              size: 81
      cmp1:
        FuncExpr:
          source: 'cmp<Huge>(neg1, rem0)'
          name: cmp_81
          args:
          - 
            SliceExpr:
              source: 'neg1'
              var: neg1
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 81
      posRem:
        LutExpr:
          name: isPositive
          args: 
            - 
              SliceExpr:
                source: 'remSign'
                var: remSign
                offset: 0
                size: 1
      posQuo:
        LutExpr:
          name: isPositive
          args: 
            - 
              SliceExpr:
                source: 'quoSign'
                var: quoSign
                offset: 0
                size: 1
      test1:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'posRem'
                var: posRem
                offset: 0
                size: 1
            - 
              LutExpr:
                name: or
                args: 
                  - 
                    LutExpr:
                      name: isLess
                      args: 
                        - 
                          SliceExpr:
                            source: 'cmp1'
                            var: cmp1
                            offset: 0
                            size: 1
                  - 
                    LutExpr:
                      name: and
                      args: 
                        - 
                          LutExpr:
                            name: isZero
                            args: 
                              - 
                                SliceExpr:
                                  source: 'cmp1'
                                  var: cmp1
                                  offset: 0
                                  size: 1
                        - 
                          SliceExpr:
                            source: 'posQuo'
                            var: posQuo
                            offset: 0
                            size: 1
      high:
        FuncExpr:
          source: 'add<Huge>(rem0, div)'
          name: add_81
          args:
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div'
              var: div
              offset: 0
              size: 81
      neg2:
        FuncExpr:
          source: 'neg<Huge>(high)'
          name: neg_81
          args:
          - 
            SliceExpr:
              source: 'high'
              var: high
              offset: 0
              size: 81
      cmp2:
        FuncExpr:
          source: 'cmp<Huge>(neg2, rem0)'
          name: cmp_81
          args:
          - 
            SliceExpr:
              source: 'neg2'
              var: neg2
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'rem0'
              var: rem0
              offset: 0
              size: 81
      negRem:
        LutExpr:
          name: isNegative
          args: 
            - 
              SliceExpr:
                source: 'remSign'
                var: remSign
                offset: 0
                size: 1
      negQuo:
        LutExpr:
          name: isNegative
          args: 
            - 
              SliceExpr:
                source: 'quoSign'
                var: quoSign
                offset: 0
                size: 1
      test2:
        LutExpr:
          name: and
          args: 
            - 
              SliceExpr:
                source: 'negRem'
                var: negRem
                offset: 0
                size: 1
            - 
              LutExpr:
                name: or
                args: 
                  - 
                    LutExpr:
                      name: isGreater
                      args: 
                        - 
                          SliceExpr:
                            source: 'cmp2'
                            var: cmp2
                            offset: 0
                            size: 1
                  - 
                    LutExpr:
                      name: and
                      args: 
                        - 
                          LutExpr:
                            name: isEqual
                            args: 
                              - 
                                SliceExpr:
                                  source: 'cmp2'
                                  var: cmp2
                                  offset: 0
                                  size: 1
                        - 
                          SliceExpr:
                            source: 'negQuo'
                            var: negQuo
                            offset: 0
                            size: 1
      quorem1:
        TypeExpr:
          source: 'T2{ /   quotient = incr<Huge>(quo0) /   remainder = low / }'
          type: 
            ConstTypeName:
              typeName: T2
              size: 162
              fields:
                quotient: 
                  size: '81'
                  offset: '0'
                remainder: 
                  size: '81'
                  offset: '81'
          fieldValues: 
            quotient:
              FuncExpr:
                source: 'incr<Huge>(quo0)'
                name: incr_81
                args:
                - 
                  SliceExpr:
                    source: 'quo0'
                    var: quo0
                    offset: 0
                    size: 81
            remainder:
              SliceExpr:
                source: 'low'
                var: low
                offset: 0
                size: 81
      quorem2:
        TypeExpr:
          source: 'T2{ /   quotient = decr<Huge>(quo0) /   remainder = high / }'
          type: 
            ConstTypeName:
              typeName: T2
              size: 162
              fields:
                quotient: 
                  size: '81'
                  offset: '0'
                remainder: 
                  size: '81'
                  offset: '81'
          fieldValues: 
            quotient:
              FuncExpr:
                source: 'decr<Huge>(quo0)'
                name: decr_81
                args:
                - 
                  SliceExpr:
                    source: 'quo0'
                    var: quo0
                    offset: 0
                    size: 81
            remainder:
              SliceExpr:
                source: 'high'
                var: high
                offset: 0
                size: 81
    return: 
    # test1 ? quorem1 : test2 ? quorem2 : quorem
      CondExpr:
        source: 'test1 ? quorem1 : test2 ? quorem2 : quorem'
        if: 
          SliceExpr:
            source: 'test1'
            var: test1
            offset: 0
            size: 1
        then: 
          SliceExpr:
            source: 'quorem1'
            var: quorem1
            offset: 0
            size: 162
        else:
          CondExpr:
            source: 'test2 ? quorem2 : quorem'
            if: 
              SliceExpr:
                source: 'test2'
                var: test2
                offset: 0
                size: 1
            then: 
              SliceExpr:
                source: 'quorem2'
                var: quorem2
                offset: 0
                size: 162
            else:
              SliceExpr:
                source: 'quorem'
                var: quorem
                offset: 0
                size: 162
# 
# func T2 fixSign<Huge>(Huge lhs, Huge rhs, Huge quo, Huge rem) {
#   lhsSign = sign<Huge>(lhs)
#   rhsSign = sign<Huge>(rhs)
#   negRem = isNegative[lhsSign]
#   negQuo = xor[negRem, isNegative[rhsSign]]
#   quo1 = negQuo ? neg<Huge>(quo) : quo
#   rem1 = negRem ? neg<Huge>(rem) : rem
#   return T2{
#     quotient = quo1
#     remainder = rem1
#   }
# }
  fixSign_81:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: lhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rhs
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: quo
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: rem
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      lhsSign:
        FuncExpr:
          source: 'sign<Huge>(lhs)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 81
      rhsSign:
        FuncExpr:
          source: 'sign<Huge>(rhs)'
          name: sign_81
          args:
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 81
      negRem:
        LutExpr:
          name: isNegative
          args: 
            - 
              SliceExpr:
                source: 'lhsSign'
                var: lhsSign
                offset: 0
                size: 1
      negQuo:
        LutExpr:
          name: xor
          args: 
            - 
              SliceExpr:
                source: 'negRem'
                var: negRem
                offset: 0
                size: 1
            - 
              LutExpr:
                name: isNegative
                args: 
                  - 
                    SliceExpr:
                      source: 'rhsSign'
                      var: rhsSign
                      offset: 0
                      size: 1
      quo1:
        CondExpr:
          source: 'negQuo ? neg<Huge>(quo) : quo'
          if: 
            SliceExpr:
              source: 'negQuo'
              var: negQuo
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'neg<Huge>(quo)'
              name: neg_81
              args:
              - 
                SliceExpr:
                  source: 'quo'
                  var: quo
                  offset: 0
                  size: 81
          else:
            SliceExpr:
              source: 'quo'
              var: quo
              offset: 0
              size: 81
      rem1:
        CondExpr:
          source: 'negRem ? neg<Huge>(rem) : rem'
          if: 
            SliceExpr:
              source: 'negRem'
              var: negRem
              offset: 0
              size: 1
          then: 
            FuncExpr:
              source: 'neg<Huge>(rem)'
              name: neg_81
              args:
              - 
                SliceExpr:
                  source: 'rem'
                  var: rem
                  offset: 0
                  size: 81
          else:
            SliceExpr:
              source: 'rem'
              var: rem
              offset: 0
              size: 81
    return: 
    # T2{
    #   quotient = quo1
    #   remainder = rem1
    # }
      TypeExpr:
        source: 'T2{ /   quotient = quo1 /   remainder = rem1 / }'
        type: 
          ConstTypeName:
            typeName: T2
            size: 162
            fields:
              quotient: 
                size: '81'
                offset: '0'
              remainder: 
                size: '81'
                offset: '81'
        fieldValues: 
          quotient:
            SliceExpr:
              source: 'quo1'
              var: quo1
              offset: 0
              size: 81
          remainder:
            SliceExpr:
              source: 'rem1'
              var: rem1
              offset: 0
              size: 81
# 
# func Huge abs<Huge>(Huge val) {
#   return isNegative[sign<Huge>(val)] ? neg<Huge>(val) : val
# }
  abs_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # isNegative[sign<Huge>(val)] ? neg<Huge>(val) : val
      CondExpr:
        source: 'isNegative[sign<Huge>(val)] ? neg<Huge>(val) : val'
        if: 
          LutExpr:
            name: isNegative
            args: 
              - 
                FuncExpr:
                  source: 'sign<Huge>(val)'
                  name: sign_81
                  args:
                  - 
                    SliceExpr:
                      source: 'val'
                      var: val
                      offset: 0
                      size: 81
        then: 
          FuncExpr:
            source: 'neg<Huge>(val)'
            name: neg_81
            args:
            - 
              SliceExpr:
                source: 'val'
                var: val
                offset: 0
                size: 81
        else:
          SliceExpr:
            source: 'val'
            var: val
            offset: 0
            size: 81
# 
# func T2 as<T2>(T2 val) {
#   return val
# }
  as_162:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: val
        size: 162
        type: 
          ConstTypeName:
            typeName: T2
            size: 162
            fields:
              quotient: 
                size: '81'
                offset: '0'
              remainder: 
                size: '81'
                offset: '81'
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 162
# 
# func T2 rshift<T2>(T2 val) {
#   return 0 & val[0 : T2 - 1]
# }
  rshift_162:
    returnType: 
      ConstTypeName:
        typeName: T2
        size: 162
        fields:
          quotient: 
            size: '81'
            offset: '0'
          remainder: 
            size: '81'
            offset: '81'
    params:
      - 
        argName: val
        size: 162
        type: 
          ConstTypeName:
            typeName: T2
            size: 162
            fields:
              quotient: 
                size: '81'
                offset: '0'
              remainder: 
                size: '81'
                offset: '81'
    return: 
    # 0 & val[0 : T2 - 1]
      ConcatExpr:
        source: '0 & val[0 : T2 - 1]'
        lhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
        rhs: 
          SliceExpr:
            source: 'val[0 : T2 - 1]'
            var: val
            offset: 0
            size: 161
            start:
              ConstNumber:
                value: 0
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: T2
                    size: 162
                    fields:
                      quotient: 
                        size: '81'
                        offset: '0'
                      remainder: 
                        size: '81'
                        offset: '81'
                rhs: 
                  ConstNumber:
                    value: 1
# 
# func Huge incr<Huge>(Huge val) {
#   halfSum = halfAdd<Huge>(val, 1)
#   return halfSum.value
# }
  incr_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      halfSum:
        FuncExpr:
          source: 'halfAdd<Huge>(val, 1)'
          name: halfAdd_81
          args:
          - 
            SliceExpr:
              source: 'val'
              var: val
              offset: 0
              size: 81
          - 
            ValueExpr:
                value: '1'
                trits: '1'
                trytes: 'A'
    return: 
    # halfSum.value
      SliceExpr:
        source: 'halfSum.value'
        var: halfSum
        offset: 0
        size: 81
        fields: 
          - value
# 
# func Huge rshift<Huge>(Huge val) {
#   return 0 & val[0 : Huge - 1]
# }
  rshift_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # 0 & val[0 : Huge - 1]
      ConcatExpr:
        source: '0 & val[0 : Huge - 1]'
        lhs: 
          ValueExpr:
              value: '0'
              trits: '0'
              trytes: '9'
        rhs: 
          SliceExpr:
            source: 'val[0 : Huge - 1]'
            var: val
            offset: 0
            size: 80
            start:
              ConstNumber:
                value: 0
            end:
              ConstExpr:
                operator: '-'
                lhs: 
                  ConstTypeName:
                    typeName: Huge
                    size: 81
                rhs: 
                  ConstNumber:
                    value: 1
# 
# func Int print<Int>(Int val) {
#   return val
# }
  print_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 27
# 
# func Int as<Int>(Int val) {
#   return val
# }
  as_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 27
# 
# func Bool sqrtCheckBound<Int>(Int n, Int x) {
#   return notGreater[cmp<T2>(fullMul<Int>(x, x), n & as<Int>(0))]
# }
  sqrtCheckBound_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: x
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # notGreater[cmp<T2>(fullMul<Int>(x, x), n & as<Int>(0))]
      LutExpr:
        name: notGreater
        args: 
          - 
            FuncExpr:
              source: 'cmp<T2>(fullMul<Int>(x, x), n & as<Int>(0))'
              name: cmp_54
              args:
              - 
                FuncExpr:
                  source: 'fullMul<Int>(x, x)'
                  name: fullMul_27
                  args:
                  - 
                    SliceExpr:
                      source: 'x'
                      var: x
                      offset: 0
                      size: 27
                  - 
                    SliceExpr:
                      source: 'x'
                      var: x
                      offset: 0
                      size: 27
              - 
                ConcatExpr:
                  source: 'n & as<Int>(0)'
                  lhs: 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 27
                  rhs: 
                    FuncExpr:
                      source: 'as<Int>(0)'
                      name: as_27
                      args:
                      - 
                        ValueExpr:
                            value: '0'
                            trits: '000000000000000000000000000'
                            trytes: '999999999'
# 
# func Bool sqrtInInterval<Int>(Int n, Int lower, Int upper) {
#   return not[sqrtCheckBound<Int>(n, lower)] ? - : not[sqrtCheckBound<Int>(n, upper)]
# }
  sqrtInInterval_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: lower
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: upper
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # not[sqrtCheckBound<Int>(n, lower)] ? - : not[sqrtCheckBound<Int>(n, upper)]
      CondExpr:
        source: 'not[sqrtCheckBound<Int>(n, lower)] ? - : not[sqrtCheckBound<Int>(n, upper)]'
        if: 
          LutExpr:
            name: not
            args: 
              - 
                FuncExpr:
                  source: 'sqrtCheckBound<Int>(n, lower)'
                  name: sqrtCheckBound_27
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 27
                  - 
                    SliceExpr:
                      source: 'lower'
                      var: lower
                      offset: 0
                      size: 27
        then: 
          ValueExpr:
              value: '-'
              trits: '-'
              trytes: 'Z'
        else:
          LutExpr:
            name: not
            args: 
              - 
                FuncExpr:
                  source: 'sqrtCheckBound<Int>(n, upper)'
                  name: sqrtCheckBound_27
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 27
                  - 
                    SliceExpr:
                      source: 'upper'
                      var: upper
                      offset: 0
                      size: 27
# 
# func Int sqrtFindInInterval<Int>(Int n, Int lower, Int upper) {
#   len = sub<Int>(upper, lower)
#   return sqrtInInterval<Int>(n, lower, upper) ? (equal<Int>(len, 1) ? lower : equal<Int>(len, 2) ? sqrtCheck2values<Int>(n, lower) : sqrtTrichotomy<Int>(n, lower, upper)) : null
# }
  sqrtFindInInterval_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: lower
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: upper
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      len:
        FuncExpr:
          source: 'sub<Int>(upper, lower)'
          name: sub_27
          args:
          - 
            SliceExpr:
              source: 'upper'
              var: upper
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'lower'
              var: lower
              offset: 0
              size: 27
    return: 
    # sqrtInInterval<Int>(n, lower, upper) ? (equal<Int>(len, 1) ? lower : equal<Int>(len, 2) ? sqrtCheck2values<Int>(n, lower) : sqrtTrichotomy<Int>(n, lower, upper)) : null
      CondExpr:
        source: 'sqrtInInterval<Int>(n, lower, upper) ? (equal<Int>(len, 1) ? lower : equal<Int>(len, 2) ? sqrtCheck2values<Int>(n, lower) : sqrtTrichotomy<Int>(n, lower, upper)) : null'
        if: 
          FuncExpr:
            source: 'sqrtInInterval<Int>(n, lower, upper)'
            name: sqrtInInterval_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'lower'
                var: lower
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'upper'
                var: upper
                offset: 0
                size: 27
        then: 
          CondExpr:
            source: 'equal<Int>(len, 1) ? lower : equal<Int>(len, 2) ? sqrtCheck2values<Int>(n, lower) : sqrtTrichotomy<Int>(n, lower, upper)'
            if: 
              FuncExpr:
                source: 'equal<Int>(len, 1)'
                name: equal_27
                args:
                - 
                  SliceExpr:
                    source: 'len'
                    var: len
                    offset: 0
                    size: 27
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000'
                      trytes: 'A99999999'
            then: 
              SliceExpr:
                source: 'lower'
                var: lower
                offset: 0
                size: 27
            else:
              CondExpr:
                source: 'equal<Int>(len, 2) ? sqrtCheck2values<Int>(n, lower) : sqrtTrichotomy<Int>(n, lower, upper)'
                if: 
                  FuncExpr:
                    source: 'equal<Int>(len, 2)'
                    name: equal_27
                    args:
                    - 
                      SliceExpr:
                        source: 'len'
                        var: len
                        offset: 0
                        size: 27
                    - 
                      ValueExpr:
                          value: '2'
                          trits: '-10000000000000000000000000'
                          trytes: 'B99999999'
                then: 
                  FuncExpr:
                    source: 'sqrtCheck2values<Int>(n, lower)'
                    name: sqrtCheck2values_27
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 27
                    - 
                      SliceExpr:
                        source: 'lower'
                        var: lower
                        offset: 0
                        size: 27
                else:
                  FuncExpr:
                    source: 'sqrtTrichotomy<Int>(n, lower, upper)'
                    name: sqrtTrichotomy_27
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 27
                    - 
                      SliceExpr:
                        source: 'lower'
                        var: lower
                        offset: 0
                        size: 27
                    - 
                      SliceExpr:
                        source: 'upper'
                        var: upper
                        offset: 0
                        size: 27
        else:
          NullExpr: ''
# 
# func Int sqrtCheck2values<Int>(Int n, Int lower) {
#   i1 = incr<Int>(lower)
#   i2 = incr<Int>(i1)
#   return sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2)
# }
  sqrtCheck2values_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: lower
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      i1:
        FuncExpr:
          source: 'incr<Int>(lower)'
          name: incr_27
          args:
          - 
            SliceExpr:
              source: 'lower'
              var: lower
              offset: 0
              size: 27
      i2:
        FuncExpr:
          source: 'incr<Int>(i1)'
          name: incr_27
          args:
          - 
            SliceExpr:
              source: 'i1'
              var: i1
              offset: 0
              size: 27
    return: 
    # sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2)
      MergeExpr:
        source: 'sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2)'
        lhs: 
          FuncExpr:
            source: 'sqrtFindInInterval<Int>(n, lower, i1)'
            name: sqrtFindInInterval_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'lower'
                var: lower
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'i1'
                var: i1
                offset: 0
                size: 27
        rhs: 
          FuncExpr:
            source: 'sqrtFindInInterval<Int>(n, i1, i2)'
            name: sqrtFindInInterval_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'i1'
                var: i1
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'i2'
                var: i2
                offset: 0
                size: 27
# 
# func Int sqrtTrichotomy<Int>(Int n, Int lower, Int upper) {
#   div3 = lshift<Int>(sub<Int>(upper, lower))
#   i1 = add<Int>(lower, div3)
#   i2 = add<Int>(i1, div3)
#   return sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2) | sqrtFindInInterval<Int>(n, i2, upper)
# }
  sqrtTrichotomy_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: lower
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: upper
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      div3:
        FuncExpr:
          source: 'lshift<Int>(sub<Int>(upper, lower))'
          name: lshift_27
          args:
          - 
            FuncExpr:
              source: 'sub<Int>(upper, lower)'
              name: sub_27
              args:
              - 
                SliceExpr:
                  source: 'upper'
                  var: upper
                  offset: 0
                  size: 27
              - 
                SliceExpr:
                  source: 'lower'
                  var: lower
                  offset: 0
                  size: 27
      i1:
        FuncExpr:
          source: 'add<Int>(lower, div3)'
          name: add_27
          args:
          - 
            SliceExpr:
              source: 'lower'
              var: lower
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 27
      i2:
        FuncExpr:
          source: 'add<Int>(i1, div3)'
          name: add_27
          args:
          - 
            SliceExpr:
              source: 'i1'
              var: i1
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 27
    return: 
    # sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2) | sqrtFindInInterval<Int>(n, i2, upper)
      MergeExpr:
        source: 'sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2) | sqrtFindInInterval<Int>(n, i2, upper)'
        lhs: 
          MergeExpr:
            source: 'sqrtFindInInterval<Int>(n, lower, i1) | sqrtFindInInterval<Int>(n, i1, i2)'
            lhs: 
              FuncExpr:
                source: 'sqrtFindInInterval<Int>(n, lower, i1)'
                name: sqrtFindInInterval_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'lower'
                    var: lower
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'i1'
                    var: i1
                    offset: 0
                    size: 27
            rhs: 
              FuncExpr:
                source: 'sqrtFindInInterval<Int>(n, i1, i2)'
                name: sqrtFindInInterval_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'i1'
                    var: i1
                    offset: 0
                    size: 27
                - 
                  SliceExpr:
                    source: 'i2'
                    var: i2
                    offset: 0
                    size: 27
        rhs: 
          FuncExpr:
            source: 'sqrtFindInInterval<Int>(n, i2, upper)'
            name: sqrtFindInInterval_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'i2'
                var: i2
                offset: 0
                size: 27
            - 
              SliceExpr:
                source: 'upper'
                var: upper
                offset: 0
                size: 27
# 
# func Int sqrtFloor<Int>(Int n) {
#   return equal<Int>(n, 0) ? 0 : equal<Int>(n, 1) ? 1 : sqrtFindInInterval<Int>(n, 1, n)
# }
  sqrtFloor_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    return: 
    # equal<Int>(n, 0) ? 0 : equal<Int>(n, 1) ? 1 : sqrtFindInInterval<Int>(n, 1, n)
      CondExpr:
        source: 'equal<Int>(n, 0) ? 0 : equal<Int>(n, 1) ? 1 : sqrtFindInInterval<Int>(n, 1, n)'
        if: 
          FuncExpr:
            source: 'equal<Int>(n, 0)'
            name: equal_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
            - 
              ValueExpr:
                  value: '0'
                  trits: '000000000000000000000000000'
                  trytes: '999999999'
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000'
              trytes: '999999999'
        else:
          CondExpr:
            source: 'equal<Int>(n, 1) ? 1 : sqrtFindInInterval<Int>(n, 1, n)'
            if: 
              FuncExpr:
                source: 'equal<Int>(n, 1)'
                name: equal_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000'
                      trytes: 'A99999999'
            then: 
              ValueExpr:
                  value: '1'
                  trits: '100000000000000000000000000'
                  trytes: 'A99999999'
            else:
              FuncExpr:
                source: 'sqrtFindInInterval<Int>(n, 1, n)'
                name: sqrtFindInInterval_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000'
                      trytes: 'A99999999'
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
# 
# func Trit cmp<T2>(T2 lhs, T2 rhs) {
#   val0 = cmp<A>(lhs[0 : A], rhs[0 : A])
#   val1 = cmp<B>(lhs[A : B], rhs[A : B])
#   return sign[val0, val1, 0]
# }
  cmp_54:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 54
        type: 
          ConstTypeName:
            typeName: T2
            size: 54
      - 
        argName: rhs
        size: 54
        type: 
          ConstTypeName:
            typeName: T2
            size: 54
    assigns: 
      val0:
        FuncExpr:
          source: 'cmp<A>(lhs[0 : A], rhs[0 : A])'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 27
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 27
      val1:
        FuncExpr:
          source: 'cmp<B>(lhs[A : B], rhs[A : B])'
          name: cmp_27
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 27
              size: 27
              start:
                ConstTypeName:
                  typeName: A
                  size: 27
              end:
                ConstTypeName:
                  typeName: B
                  size: 27
    return: 
    # sign[val0, val1, 0]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
# 
# func Bool sqrtCheckBound<Huge>(Huge n, Huge x) {
#   return notGreater[cmp<T2>(fullMul<Huge>(x, x), n & as<Huge>(0))]
# }
  sqrtCheckBound_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: x
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # notGreater[cmp<T2>(fullMul<Huge>(x, x), n & as<Huge>(0))]
      LutExpr:
        name: notGreater
        args: 
          - 
            FuncExpr:
              source: 'cmp<T2>(fullMul<Huge>(x, x), n & as<Huge>(0))'
              name: cmp_162
              args:
              - 
                FuncExpr:
                  source: 'fullMul<Huge>(x, x)'
                  name: fullMul_81
                  args:
                  - 
                    SliceExpr:
                      source: 'x'
                      var: x
                      offset: 0
                      size: 81
                  - 
                    SliceExpr:
                      source: 'x'
                      var: x
                      offset: 0
                      size: 81
              - 
                ConcatExpr:
                  source: 'n & as<Huge>(0)'
                  lhs: 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 81
                  rhs: 
                    FuncExpr:
                      source: 'as<Huge>(0)'
                      name: as_81
                      args:
                      - 
                        ValueExpr:
                            value: '0'
                            trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                            trytes: '999999999999999999999999999'
# 
# func Bool sqrtInInterval<Huge>(Huge n, Huge lower, Huge upper) {
#   return not[sqrtCheckBound<Huge>(n, lower)] ? - : not[sqrtCheckBound<Huge>(n, upper)]
# }
  sqrtInInterval_81:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: lower
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: upper
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # not[sqrtCheckBound<Huge>(n, lower)] ? - : not[sqrtCheckBound<Huge>(n, upper)]
      CondExpr:
        source: 'not[sqrtCheckBound<Huge>(n, lower)] ? - : not[sqrtCheckBound<Huge>(n, upper)]'
        if: 
          LutExpr:
            name: not
            args: 
              - 
                FuncExpr:
                  source: 'sqrtCheckBound<Huge>(n, lower)'
                  name: sqrtCheckBound_81
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 81
                  - 
                    SliceExpr:
                      source: 'lower'
                      var: lower
                      offset: 0
                      size: 81
        then: 
          ValueExpr:
              value: '-'
              trits: '-'
              trytes: 'Z'
        else:
          LutExpr:
            name: not
            args: 
              - 
                FuncExpr:
                  source: 'sqrtCheckBound<Huge>(n, upper)'
                  name: sqrtCheckBound_81
                  args:
                  - 
                    SliceExpr:
                      source: 'n'
                      var: n
                      offset: 0
                      size: 81
                  - 
                    SliceExpr:
                      source: 'upper'
                      var: upper
                      offset: 0
                      size: 81
# 
# func Huge sqrtFindInInterval<Huge>(Huge n, Huge lower, Huge upper) {
#   len = sub<Huge>(upper, lower)
#   return sqrtInInterval<Huge>(n, lower, upper) ? (equal<Huge>(len, 1) ? lower : equal<Huge>(len, 2) ? sqrtCheck2values<Huge>(n, lower) : sqrtTrichotomy<Huge>(n, lower, upper)) : null
# }
  sqrtFindInInterval_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: lower
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: upper
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      len:
        FuncExpr:
          source: 'sub<Huge>(upper, lower)'
          name: sub_81
          args:
          - 
            SliceExpr:
              source: 'upper'
              var: upper
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'lower'
              var: lower
              offset: 0
              size: 81
    return: 
    # sqrtInInterval<Huge>(n, lower, upper) ? (equal<Huge>(len, 1) ? lower : equal<Huge>(len, 2) ? sqrtCheck2values<Huge>(n, lower) : sqrtTrichotomy<Huge>(n, lower, upper)) : null
      CondExpr:
        source: 'sqrtInInterval<Huge>(n, lower, upper) ? (equal<Huge>(len, 1) ? lower : equal<Huge>(len, 2) ? sqrtCheck2values<Huge>(n, lower) : sqrtTrichotomy<Huge>(n, lower, upper)) : null'
        if: 
          FuncExpr:
            source: 'sqrtInInterval<Huge>(n, lower, upper)'
            name: sqrtInInterval_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'lower'
                var: lower
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'upper'
                var: upper
                offset: 0
                size: 81
        then: 
          CondExpr:
            source: 'equal<Huge>(len, 1) ? lower : equal<Huge>(len, 2) ? sqrtCheck2values<Huge>(n, lower) : sqrtTrichotomy<Huge>(n, lower, upper)'
            if: 
              FuncExpr:
                source: 'equal<Huge>(len, 1)'
                name: equal_81
                args:
                - 
                  SliceExpr:
                    source: 'len'
                    var: len
                    offset: 0
                    size: 81
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                      trytes: 'A99999999999999999999999999'
            then: 
              SliceExpr:
                source: 'lower'
                var: lower
                offset: 0
                size: 81
            else:
              CondExpr:
                source: 'equal<Huge>(len, 2) ? sqrtCheck2values<Huge>(n, lower) : sqrtTrichotomy<Huge>(n, lower, upper)'
                if: 
                  FuncExpr:
                    source: 'equal<Huge>(len, 2)'
                    name: equal_81
                    args:
                    - 
                      SliceExpr:
                        source: 'len'
                        var: len
                        offset: 0
                        size: 81
                    - 
                      ValueExpr:
                          value: '2'
                          trits: '-10000000000000000000000000000000000000000000000000000000000000000000000000000000'
                          trytes: 'B99999999999999999999999999'
                then: 
                  FuncExpr:
                    source: 'sqrtCheck2values<Huge>(n, lower)'
                    name: sqrtCheck2values_81
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 81
                    - 
                      SliceExpr:
                        source: 'lower'
                        var: lower
                        offset: 0
                        size: 81
                else:
                  FuncExpr:
                    source: 'sqrtTrichotomy<Huge>(n, lower, upper)'
                    name: sqrtTrichotomy_81
                    args:
                    - 
                      SliceExpr:
                        source: 'n'
                        var: n
                        offset: 0
                        size: 81
                    - 
                      SliceExpr:
                        source: 'lower'
                        var: lower
                        offset: 0
                        size: 81
                    - 
                      SliceExpr:
                        source: 'upper'
                        var: upper
                        offset: 0
                        size: 81
        else:
          NullExpr: ''
# 
# func Huge sqrtCheck2values<Huge>(Huge n, Huge lower) {
#   i1 = incr<Huge>(lower)
#   i2 = incr<Huge>(i1)
#   return sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2)
# }
  sqrtCheck2values_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: lower
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      i1:
        FuncExpr:
          source: 'incr<Huge>(lower)'
          name: incr_81
          args:
          - 
            SliceExpr:
              source: 'lower'
              var: lower
              offset: 0
              size: 81
      i2:
        FuncExpr:
          source: 'incr<Huge>(i1)'
          name: incr_81
          args:
          - 
            SliceExpr:
              source: 'i1'
              var: i1
              offset: 0
              size: 81
    return: 
    # sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2)
      MergeExpr:
        source: 'sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2)'
        lhs: 
          FuncExpr:
            source: 'sqrtFindInInterval<Huge>(n, lower, i1)'
            name: sqrtFindInInterval_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'lower'
                var: lower
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'i1'
                var: i1
                offset: 0
                size: 81
        rhs: 
          FuncExpr:
            source: 'sqrtFindInInterval<Huge>(n, i1, i2)'
            name: sqrtFindInInterval_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'i1'
                var: i1
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'i2'
                var: i2
                offset: 0
                size: 81
# 
# func Huge sqrtTrichotomy<Huge>(Huge n, Huge lower, Huge upper) {
#   div3 = lshift<Huge>(sub<Huge>(upper, lower))
#   i1 = add<Huge>(lower, div3)
#   i2 = add<Huge>(i1, div3)
#   return sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2) | sqrtFindInInterval<Huge>(n, i2, upper)
# }
  sqrtTrichotomy_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: lower
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
      - 
        argName: upper
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    assigns: 
      div3:
        FuncExpr:
          source: 'lshift<Huge>(sub<Huge>(upper, lower))'
          name: lshift_81
          args:
          - 
            FuncExpr:
              source: 'sub<Huge>(upper, lower)'
              name: sub_81
              args:
              - 
                SliceExpr:
                  source: 'upper'
                  var: upper
                  offset: 0
                  size: 81
              - 
                SliceExpr:
                  source: 'lower'
                  var: lower
                  offset: 0
                  size: 81
      i1:
        FuncExpr:
          source: 'add<Huge>(lower, div3)'
          name: add_81
          args:
          - 
            SliceExpr:
              source: 'lower'
              var: lower
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 81
      i2:
        FuncExpr:
          source: 'add<Huge>(i1, div3)'
          name: add_81
          args:
          - 
            SliceExpr:
              source: 'i1'
              var: i1
              offset: 0
              size: 81
          - 
            SliceExpr:
              source: 'div3'
              var: div3
              offset: 0
              size: 81
    return: 
    # sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2) | sqrtFindInInterval<Huge>(n, i2, upper)
      MergeExpr:
        source: 'sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2) | sqrtFindInInterval<Huge>(n, i2, upper)'
        lhs: 
          MergeExpr:
            source: 'sqrtFindInInterval<Huge>(n, lower, i1) | sqrtFindInInterval<Huge>(n, i1, i2)'
            lhs: 
              FuncExpr:
                source: 'sqrtFindInInterval<Huge>(n, lower, i1)'
                name: sqrtFindInInterval_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'lower'
                    var: lower
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'i1'
                    var: i1
                    offset: 0
                    size: 81
            rhs: 
              FuncExpr:
                source: 'sqrtFindInInterval<Huge>(n, i1, i2)'
                name: sqrtFindInInterval_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'i1'
                    var: i1
                    offset: 0
                    size: 81
                - 
                  SliceExpr:
                    source: 'i2'
                    var: i2
                    offset: 0
                    size: 81
        rhs: 
          FuncExpr:
            source: 'sqrtFindInInterval<Huge>(n, i2, upper)'
            name: sqrtFindInInterval_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'i2'
                var: i2
                offset: 0
                size: 81
            - 
              SliceExpr:
                source: 'upper'
                var: upper
                offset: 0
                size: 81
# 
# func Huge sqrtFloor<Huge>(Huge n) {
#   return equal<Huge>(n, 0) ? 0 : equal<Huge>(n, 1) ? 1 : sqrtFindInInterval<Huge>(n, 1, n)
# }
  sqrtFloor_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: n
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # equal<Huge>(n, 0) ? 0 : equal<Huge>(n, 1) ? 1 : sqrtFindInInterval<Huge>(n, 1, n)
      CondExpr:
        source: 'equal<Huge>(n, 0) ? 0 : equal<Huge>(n, 1) ? 1 : sqrtFindInInterval<Huge>(n, 1, n)'
        if: 
          FuncExpr:
            source: 'equal<Huge>(n, 0)'
            name: equal_81
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 81
            - 
              ValueExpr:
                  value: '0'
                  trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
                  trytes: '999999999999999999999999999'
        then: 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: '999999999999999999999999999'
        else:
          CondExpr:
            source: 'equal<Huge>(n, 1) ? 1 : sqrtFindInInterval<Huge>(n, 1, n)'
            if: 
              FuncExpr:
                source: 'equal<Huge>(n, 1)'
                name: equal_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                      trytes: 'A99999999999999999999999999'
            then: 
              ValueExpr:
                  value: '1'
                  trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                  trytes: 'A99999999999999999999999999'
            else:
              FuncExpr:
                source: 'sqrtFindInInterval<Huge>(n, 1, n)'
                name: sqrtFindInInterval_81
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
                - 
                  ValueExpr:
                      value: '1'
                      trits: '100000000000000000000000000000000000000000000000000000000000000000000000000000000'
                      trytes: 'A99999999999999999999999999'
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 81
# 
# func Trit cmp<T2>(T2 lhs, T2 rhs) {
#   val0 = cmp<A>(lhs[0 : A], rhs[0 : A])
#   val1 = cmp<B>(lhs[A : B], rhs[A : B])
#   return sign[val0, val1, 0]
# }
  cmp_162:
    returnType: 
      ConstTypeName:
        typeName: Trit
        size: 1
    params:
      - 
        argName: lhs
        size: 162
        type: 
          ConstTypeName:
            typeName: T2
            size: 162
      - 
        argName: rhs
        size: 162
        type: 
          ConstTypeName:
            typeName: T2
            size: 162
    assigns: 
      val0:
        FuncExpr:
          source: 'cmp<A>(lhs[0 : A], rhs[0 : A])'
          name: cmp_81
          args:
          - 
            SliceExpr:
              source: 'lhs[0 : A]'
              var: lhs
              offset: 0
              size: 81
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[0 : A]'
              var: rhs
              offset: 0
              size: 81
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 81
      val1:
        FuncExpr:
          source: 'cmp<B>(lhs[A : B], rhs[A : B])'
          name: cmp_81
          args:
          - 
            SliceExpr:
              source: 'lhs[A : B]'
              var: lhs
              offset: 81
              size: 81
              start:
                ConstTypeName:
                  typeName: A
                  size: 81
              end:
                ConstTypeName:
                  typeName: B
                  size: 81
          - 
            SliceExpr:
              source: 'rhs[A : B]'
              var: rhs
              offset: 81
              size: 81
              start:
                ConstTypeName:
                  typeName: A
                  size: 81
              end:
                ConstTypeName:
                  typeName: B
                  size: 81
    return: 
    # sign[val0, val1, 0]
      LutExpr:
        name: sign
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            ValueExpr:
                value: '0'
                trits: '0'
                trytes: '9'
# 
# func Huge as<Huge>(Huge val) {
#   return val
# }
  as_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 81
# 
# func Int threeXplusOne<Int>(Int n) {
#   dummy = print<Int>(n)
#   is2 = equal<Int>(n, 2)
#   return is2 ? 1 : threeXplusOneDo<Int>(n)
# }
  threeXplusOne_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      dummy:
        FuncExpr:
          source: 'print<Int>(n)'
          name: print_27
          args:
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 27
      is2:
        FuncExpr:
          source: 'equal<Int>(n, 2)'
          name: equal_27
          args:
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 27
          - 
            ValueExpr:
                value: '2'
                trits: '-10000000000000000000000000'
                trytes: 'B99999999'
    return: 
    # is2 ? 1 : threeXplusOneDo<Int>(n)
      CondExpr:
        source: 'is2 ? 1 : threeXplusOneDo<Int>(n)'
        if: 
          SliceExpr:
            source: 'is2'
            var: is2
            offset: 0
            size: 1
        then: 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
        else:
          FuncExpr:
            source: 'threeXplusOneDo<Int>(n)'
            name: threeXplusOneDo_27
            args:
            - 
              SliceExpr:
                source: 'n'
                var: n
                offset: 0
                size: 27
# 
# func Int threeXplusOneDo<Int>(Int n) {
#   isEven = even<Int>(n)
#   return threeXplusOne<Int>(isEven ? div<Int>(n, 2) : mul3add1(n))
# }
  threeXplusOneDo_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      isEven:
        FuncExpr:
          source: 'even<Int>(n)'
          name: even_27
          args:
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 27
    return: 
    # threeXplusOne<Int>(isEven ? div<Int>(n, 2) : mul3add1(n))
      FuncExpr:
        source: 'threeXplusOne<Int>(isEven ? div<Int>(n, 2) : mul3add1(n))'
        name: threeXplusOne_27
        args:
        - 
          CondExpr:
            source: 'isEven ? div<Int>(n, 2) : mul3add1(n)'
            if: 
              SliceExpr:
                source: 'isEven'
                var: isEven
                offset: 0
                size: 1
            then: 
              FuncExpr:
                source: 'div<Int>(n, 2)'
                name: div_27
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
                - 
                  ValueExpr:
                      value: '2'
                      trits: '-10000000000000000000000000'
                      trytes: 'B99999999'
            else:
              FuncExpr:
                source: 'mul3add1(n)'
                name: mul3add1
                args:
                - 
                  SliceExpr:
                    source: 'n'
                    var: n
                    offset: 0
                    size: 27
# 
# func Int mul3add1(Int n) {
#   mul3 = rshift<Int>(n)
#   return incr<Int>(mul3)
# }
  mul3add1:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: n
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      mul3:
        FuncExpr:
          source: 'rshift<Int>(n)'
          name: rshift_27
          args:
          - 
            SliceExpr:
              source: 'n'
              var: n
              offset: 0
              size: 27
    return: 
    # incr<Int>(mul3)
      FuncExpr:
        source: 'incr<Int>(mul3)'
        name: incr_27
        args:
        - 
          SliceExpr:
            source: 'mul3'
            var: mul3
            offset: 0
            size: 27
# 
# func Bool even<Int>(Int val) {
#   val0 = even<A>(val[0 : A])
#   val1 = even<B>(val[A : B])
#   val2 = even<C>(val[A + B : C])
#   return xor3[val0, val1, val2]
# }
  even_27:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: val
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      val0:
        FuncExpr:
          source: 'even<A>(val[0 : A])'
          name: even_9
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 9
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 9
      val1:
        FuncExpr:
          source: 'even<B>(val[A : B])'
          name: even_9
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 9
              size: 9
              start:
                ConstTypeName:
                  typeName: A
                  size: 9
              end:
                ConstTypeName:
                  typeName: B
                  size: 9
      val2:
        FuncExpr:
          source: 'even<C>(val[A + B : C])'
          name: even_9
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 18
              size: 9
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 9
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 9
              end:
                ConstTypeName:
                  typeName: C
                  size: 9
    return: 
    # xor3[val0, val1, val2]
      LutExpr:
        name: xor3
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Bool even<A>(A val) {
#   val0 = even<A>(val[0 : A])
#   val1 = even<B>(val[A : B])
#   val2 = even<C>(val[A + B : C])
#   return xor3[val0, val1, val2]
# }
  even_9:
    returnType: 
      ConstTypeName:
        typeName: Bool
        size: 1
    params:
      - 
        argName: val
        size: 9
        type: 
          ConstTypeName:
            typeName: A
            size: 9
    assigns: 
      val0:
        FuncExpr:
          source: 'even<A>(val[0 : A])'
          name: even_3
          args:
          - 
            SliceExpr:
              source: 'val[0 : A]'
              var: val
              offset: 0
              size: 3
              start:
                ConstNumber:
                  value: 0
              end:
                ConstTypeName:
                  typeName: A
                  size: 3
      val1:
        FuncExpr:
          source: 'even<B>(val[A : B])'
          name: even_3
          args:
          - 
            SliceExpr:
              source: 'val[A : B]'
              var: val
              offset: 3
              size: 3
              start:
                ConstTypeName:
                  typeName: A
                  size: 3
              end:
                ConstTypeName:
                  typeName: B
                  size: 3
      val2:
        FuncExpr:
          source: 'even<C>(val[A + B : C])'
          name: even_3
          args:
          - 
            SliceExpr:
              source: 'val[A + B : C]'
              var: val
              offset: 6
              size: 3
              start:
                ConstExpr:
                  operator: '+'
                  lhs: 
                    ConstTypeName:
                      typeName: A
                      size: 3
                  rhs: 
                    ConstTypeName:
                      typeName: B
                      size: 3
              end:
                ConstTypeName:
                  typeName: C
                  size: 3
    return: 
    # xor3[val0, val1, val2]
      LutExpr:
        name: xor3
        args: 
          - 
            SliceExpr:
              source: 'val0'
              var: val0
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val1'
              var: val1
              offset: 0
              size: 1
          - 
            SliceExpr:
              source: 'val2'
              var: val2
              offset: 0
              size: 1
# 
# func Int div<Int>(Int lhs, Int rhs) {
#   ret = divMod<Int>(lhs, rhs)
#   return ret.quotient
# }
  div_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      ret:
        FuncExpr:
          source: 'divMod<Int>(lhs, rhs)'
          name: divMod_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
    return: 
    # ret.quotient
      SliceExpr:
        source: 'ret.quotient'
        var: ret
        offset: 0
        size: 27
        fields: 
          - quotient
# 
# func Int ceilDiv<Int>(Int lhs, Int rhs) {
#   ret = ceilDivMod<Int>(lhs, rhs)
#   return ret.quotient
# }
  ceilDiv_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      ret:
        FuncExpr:
          source: 'ceilDivMod<Int>(lhs, rhs)'
          name: ceilDivMod_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
    return: 
    # ret.quotient
      SliceExpr:
        source: 'ret.quotient'
        var: ret
        offset: 0
        size: 27
        fields: 
          - quotient
# 
# func Int floorDiv<Int>(Int lhs, Int rhs) {
#   ret = floorDivMod<Int>(lhs, rhs)
#   return ret.quotient
# }
  floorDiv_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      ret:
        FuncExpr:
          source: 'floorDivMod<Int>(lhs, rhs)'
          name: floorDivMod_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
    return: 
    # ret.quotient
      SliceExpr:
        source: 'ret.quotient'
        var: ret
        offset: 0
        size: 27
        fields: 
          - quotient
# 
# func Int roundDiv<Int>(Int lhs, Int rhs) {
#   ret = roundDivMod<Int>(lhs, rhs)
#   return ret.quotient
# }
  roundDiv_27:
    returnType: 
      ConstTypeName:
        typeName: Int
        size: 27
    params:
      - 
        argName: lhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
      - 
        argName: rhs
        size: 27
        type: 
          ConstTypeName:
            typeName: Int
            size: 27
    assigns: 
      ret:
        FuncExpr:
          source: 'roundDivMod<Int>(lhs, rhs)'
          name: roundDivMod_27
          args:
          - 
            SliceExpr:
              source: 'lhs'
              var: lhs
              offset: 0
              size: 27
          - 
            SliceExpr:
              source: 'rhs'
              var: rhs
              offset: 0
              size: 27
    return: 
    # ret.quotient
      SliceExpr:
        source: 'ret.quotient'
        var: ret
        offset: 0
        size: 27
        fields: 
          - quotient
# 
# func Huge print<Huge>(Huge val) {
#   return val
# }
  print_81:
    returnType: 
      ConstTypeName:
        typeName: Huge
        size: 81
    params:
      - 
        argName: val
        size: 81
        type: 
          ConstTypeName:
            typeName: Huge
            size: 81
    return: 
    # val
      SliceExpr:
        source: 'val'
        var: val
        offset: 0
        size: 81
execs: 
  # test 0 = bin2trin<Int>(0)
  -
    source: 'test 0 = bin2trin<Int>(0)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '000000000000000000000000000'
          trytes: '999999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(0)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000'
              trytes: '999999999'
  # test 1 = bin2trin<Int>(1)
  -
    source: 'test 1 = bin2trin<Int>(1)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000000000000000000000'
          trytes: 'A99999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(1)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
  # test 2 = bin2trin<Int>(3)
  -
    source: 'test 2 = bin2trin<Int>(3)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000000000000000000000'
          trytes: 'B99999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(3)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '3'
              trits: '010000000000000000000000000'
              trytes: 'C99999999'
  # test 3 = bin2trin<Int>(4)
  -
    source: 'test 3 = bin2trin<Int>(4)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '3'
          trits: '010000000000000000000000000'
          trytes: 'C99999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(4)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '4'
              trits: '110000000000000000000000000'
              trytes: 'D99999999'
  # test 15 = bin2trin<Int>(40)
  -
    source: 'test 15 = bin2trin<Int>(40)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '15'
          trits: '0--100000000000000000000000'
          trytes: 'OA9999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(40)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '40'
              trits: '111100000000000000000000000'
              trytes: 'MA9999999'
  # test 255 = bin2trin<Int>(3280)
  -
    source: 'test 255 = bin2trin<Int>(3280)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '255'
          trits: '011001000000000000000000000'
          trytes: 'LI9999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(3280)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '3280'
              trits: '111111110000000000000000000'
              trytes: 'MMD999999'
  # test 65535 = bin2trin<Int>(21523360)
  -
    source: 'test 65535 = bin2trin<Int>(21523360)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '65535'
          trits: '0-10-0001010000000000000000'
          trytes: 'FXIC99999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Int>(21523360)'
        name: bin2trin_27
        args:
        - 
          ValueExpr:
              value: '21523360'
              trits: '111111111111111100000000000'
              trytes: 'MMMMMA999'
  # test 4294967295 = bin2trin<Huge>(926510094425920)
  -
    source: 'test 4294967295 = bin2trin<Huge>(926510094425920)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '4294967295'
          trits: '01-----00-1-001-10-11000000000000000000000000000000000000000000000000000000000000'
          trytes: 'UNZTIBK99999999999999999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Huge>(926510094425920)'
        name: bin2trin_81
        args:
        - 
          ValueExpr:
              value: '926510094425920'
              trits: '111111111111111111111111111111110000000000000000000000000000000000000000000000000'
              trytes: 'MMMMMMMMMMD9999999999999999'
  # test 340282366920938463463374607431768211455 = bin2trin<Hash>(5895092288869291585760436430706259332839105796137920554548480)
  -
    source: 'test 340282366920938463463374607431768211455 = bin2trin<Hash>(5895092288869291585760436430706259332839105796137920554548480)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '340282366920938463463374607431768211455'
          trits: '0101--1011-10100-111-111-011001111-1--00011-0-01110--111-100--11-1-101--01110-01-100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          trytes: 'CPJGCFVMHAMGWIYHDEVAEGBPLSUA99999999999999999999999999999999999999999999999999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Hash>(5895092288869291585760436430706259332839105796137920554548480)'
        name: bin2trin_243
        args:
        - 
          ValueExpr:
              value: '5895092288869291585760436430706259332839105796137920554548480'
              trits: '111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMD99999999999999999999999999999999999999'
  # test 115792089237316195423570985008687907853269984665640564039457584007913129639935 = bin2trin<Hash3>(69504226188572366382469893394830651557109425404264568995802412215018036314883217970500884577054804760905832770274449717760)
  -
    source: 'test 115792089237316195423570985008687907853269984665640564039457584007913129639935 = bin2trin<Hash3>(69504226188572366382469893394830651557109425404264568995802412215018036314883217970500884577054804760905832770274449717760)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '115792089237316195423570985008687907853269984665640564039457584007913129639935'
          trits: '0--01-001--100-11111---0100--0000-0-00-1-10001-101111-1--01---11--1100-100-11-1101-1--0-101----001-111-0111-100-100--1-0-00-10001-0---0--0000-01-00001110-010-01--100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          trytes: 'OUIERMVWAW9QRG9GLVPUEPDFRVDGWBPWUMHVABOYZBIQWW9HZIDHXPA99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Hash3>(69504226188572366382469893394830651557109425404264568995802412215018036314883217970500884577054804760905832770274449717760)'
        name: bin2trin_729
        args:
        - 
          ValueExpr:
              value: '69504226188572366382469893394830651557109425404264568995802412215018036314883217970500884577054804760905832770274449717760'
              trits: '111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMA9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
  # test 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095 = bin2trin<Hash3>(9661674916144457552727034361009790527700732880801664275092268814451233373207768500008969714893014677195041164647293059752576754550666470442049020239364319771280275066863699741389031161203686169060521699834121138295895752329492941497636218270720)
  -
    source: 'test 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095 = bin2trin<Hash3>(9661674916144457552727034361009790527700732880801664275092268814451233373207768500008969714893014677195041164647293059752576754550666470442049020239364319771280275066863699741389031161203686169060521699834121138295895752329492941497636218270720)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095'
          trits: '011100--110-11-1000100----0--0--1-10--0000011--0-11000110--0-0--1-0-001---0011-0011-110---110-111-01-000000-0-1101-1-011-11100-1--010-1-10-10-011--1--10-01--10-0110-0--1011001111--00-1--11-000-00-10100-0--11-10-10----0-10-1000-1--0-0-0--10--0-0--1110000-0-0010--100100----00---0-0100-01110010---0--11-0-01-110-111-011-101001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          trytes: 'LAESVACOWWEBW9LWK9DWQTXUWLZVDNDKYY9RFJTLKATHFBBHPPSUBHSOJAMPRPV9ZBAQKBBNQSAFWQOSQOM9XZSBCOWOQCXMIOQKQUDKYVJI999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Hash3>(9661674916144457552727034361009790527700732880801664275092268814451233373207768500008969714893014677195041164647293059752576754550666470442049020239364319771280275066863699741389031161203686169060521699834121138295895752329492941497636218270720)'
        name: bin2trin_729
        args:
        - 
          ValueExpr:
              value: '9661674916144457552727034361009790527700732880801664275092268814451233373207768500008969714893014677195041164647293059752576754550666470442049020239364319771280275066863699741389031161203686169060521699834121138295895752329492941497636218270720'
              trits: '111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMD999999999999999999999999999999999999999999999999999999999999999999999999'
  # test 179769308128688554841593914336777228061788645087206598745762043938980733953745707508027864856415641942640823241898028769893055642878690194031277212647185337028480491457581597864186726890708791588267512013107914692314913190551492247774529330958055264124819053398988059396676162108264800478523162911021390102523 = bin2trin<Hash9>(186695924370069331493319608213469809026120840269878529864401083138484546852557016082547942836221729172284179845394434319822072666510763444429975462187449479415343223072455417061004069708018863884709587406765210511026171923411791023565100951052266843751891497803359615503592287914493445124195050471647146311769968524981088534884337335397635320260306267407703218825677345201222906845325815734555633487154320091345760111767956553023832139344844800265683541905371098976094347829428199236771564)
  -
    source: 'test 179769308128688554841593914336777228061788645087206598745762043938980733953745707508027864856415641942640823241898028769893055642878690194031277212647185337028480491457581597864186726890708791588267512013107914692314913190551492247774529330958055264124819053398988059396676162108264800478523162911021390102523 = bin2trin<Hash9>(186695924370069331493319608213469809026120840269878529864401083138484546852557016082547942836221729172284179845394434319822072666510763444429975462187449479415343223072455417061004069708018863884709587406765210511026171923411791023565100951052266843751891497803359615503592287914493445124195050471647146311769968524981088534884337335397635320260306267407703218825677345201222906845325815734555633487154320091345760111767956553023832139344844800265683541905371098976094347829428199236771564)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '179769308128688554841593914336777228061788645087206598745762043938980733953745707508027864856415641942640823241898028769893055642878690194031277212647185337028480491457581597864186726890708791588267512013107914692314913190551492247774529330958055264124819053398988059396676162108264800478523162911021390102523'
          trits: '010-100100--0-010010-00-000101---111001010-101000-1-1--111-1000-101---1-1--01-0-0-111-1101000-0-0-01-101-0--0000-0-0-0000-1-11-1000001-101--100-0001100--00-011001--110---11-11-00-01-1-1-1--11-0----1-101--1-1-01-0-01----11--0--00000-0-0-0-11-0-010--01--1-10-00-0--00011-0-10000-0000011-111-10-0000--001010-0-11-00001--10-010--1011110011011101-010110--11---01100111110111-110-0101001-0111-1--1-11-10-01100---000011000--010--011--011-110010100--0001110000-10-0-0110-0000001--110011--10011001-100001-0----110010-001101100-100100011-0-0-1011-111-1-00101-0-00-00-1101-0-10111100---0-111---110---11110101110-01-1010--0--01--000--1-100-001100-1--100-1-1010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          trytes: 'CBCOXASR9JNMICBAFTKG9BPTPUXKGJ9QXGUO9XQ9FKB9UJER9DORLIESEGYXGTPVOEBPGHQUNVQZ9QXKQCWPGXXWIYB9Z9VMBZRZJXKZIEXSBMADMUCDEPHAMDMKXJIHVPGGXDOZIAOCWVHGAJRZLARSXDZ9UKIPADUAIQNDCZDDFI9VXBVMTIUXXFJQJMRWKPKOKDJDHBSQHWRTAZDFERGC999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
    expr: 
      FuncExpr:
        source: 'bin2trin<Hash9>(186695924370069331493319608213469809026120840269878529864401083138484546852557016082547942836221729172284179845394434319822072666510763444429975462187449479415343223072455417061004069708018863884709587406765210511026171923411791023565100951052266843751891497803359615503592287914493445124195050471647146311769968524981088534884337335397635320260306267407703218825677345201222906845325815734555633487154320091345760111767956553023832139344844800265683541905371098976094347829428199236771564)'
        name: bin2trin_2187
        args:
        - 
          ValueExpr:
              value: '186695924370069331493319608213469809026120840269878529864401083138484546852557016082547942836221729172284179845394434319822072666510763444429975462187449479415343223072455417061004069708018863884709587406765210511026171923411791023565100951052266843751891497803359615503592287914493445124195050471647146311769968524981088534884337335397635320260306267407703218825677345201222906845325815734555633487154320091345760111767956553023832139344844800265683541905371098976094347829428199236771564'
              trits: '110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'DMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMLMMMMMMMA999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999'
  # eval firstOne(12)
  -
    source: 'eval firstOne(12)'
    expr: 
      FuncExpr:
        source: 'firstOne(12)'
        name: firstOne
        args:
        - 
          ValueExpr:
              value: '12'
              trits: '011000000000000000000000000'
              trytes: 'L99999999'
  # eval firstOne(13)
  -
    source: 'eval firstOne(13)'
    expr: 
      FuncExpr:
        source: 'firstOne(13)'
        name: firstOne
        args:
        - 
          ValueExpr:
              value: '13'
              trits: '111000000000000000000000000'
              trytes: 'M99999999'
  # test 1 = factorial<Tiny>(0)
  -
    source: 'test 1 = factorial<Tiny>(0)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000'
          trytes: 'A99'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(0)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '0'
              trits: '000000000'
              trytes: '999'
  # test 1 = factorial<Tiny>(1)
  -
    source: 'test 1 = factorial<Tiny>(1)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000'
          trytes: 'A99'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(1)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '1'
              trits: '100000000'
              trytes: 'A99'
  # test 2 = factorial<Tiny>(2)
  -
    source: 'test 2 = factorial<Tiny>(2)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000'
          trytes: 'B99'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(2)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '2'
              trits: '-10000000'
              trytes: 'B99'
  # test 6 = factorial<Tiny>(3)
  -
    source: 'test 6 = factorial<Tiny>(3)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '6'
          trits: '0-1000000'
          trytes: 'F99'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(3)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '3'
              trits: '010000000'
              trytes: 'C99'
  # test 24 = factorial<Tiny>(4)
  -
    source: 'test 24 = factorial<Tiny>(4)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '24'
          trits: '0-0100000'
          trytes: 'XA9'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(4)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '4'
              trits: '110000000'
              trytes: 'D99'
  # test 120 = factorial<Tiny>(5)
  -
    source: 'test 120 = factorial<Tiny>(5)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '120'
          trits: '011110000'
          trytes: 'LD9'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(5)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '5'
              trits: '--1000000'
              trytes: 'E99'
  # test 720 = factorial<Tiny>(6)
  -
    source: 'test 720 = factorial<Tiny>(6)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '720'
          trits: '00-000100'
          trytes: 'R9A'
    expr: 
      FuncExpr:
        source: 'factorial<Tiny>(6)'
        name: factorial_9
        args:
        - 
          ValueExpr:
              value: '6'
              trits: '0-1000000'
              trytes: 'F99'
  # test 8683317618811886495518194401280000000 = factorial<Huge>(33)
  -
    source: 'test 8683317618811886495518194401280000000 = factorial<Huge>(33)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '8683317618811886495518194401280000000'
          trits: '0000000000000001-00--101--10-000-0011-101110--0111-000--1-0001111---00111-1---100'
          trytes: '99999YOJEXRIGLSHV9EZLVWLGNA'
    expr: 
      FuncExpr:
        source: 'factorial<Huge>(33)'
        name: factorial_81
        args:
        - 
          ValueExpr:
              value: '33'
              trits: '0-1100000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'FA9999999999999999999999999'
  # test 8683317618811886495518194401280000000 = factorial<Hash>(33)
  -
    source: 'test 8683317618811886495518194401280000000 = factorial<Hash>(33)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '8683317618811886495518194401280000000'
          trits: '0000000000000001-00--101--10-000-0011-101110--0111-000--1-0001111---00111-1---100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
          trytes: '99999YOJEXRIGLSHV9EZLVWLGNA999999999999999999999999999999999999999999999999999999'
    expr: 
      FuncExpr:
        source: 'factorial<Hash>(33)'
        name: factorial_243
        args:
        - 
          ValueExpr:
              value: '33'
              trits: '0-1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'FA9999999999999999999999999999999999999999999999999999999999999999999999999999999'
  # eval factorial<Hash>(78)
  -
    source: 'eval factorial<Hash>(78)'
    expr: 
      FuncExpr:
        source: 'factorial<Hash>(78)'
        name: factorial_243
        args:
        - 
          ValueExpr:
              value: '78'
              trits: '0-0010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'XC9999999999999999999999999999999999999999999999999999999999999999999999999999999'
  # eval factorial<Hash>(79)
  -
    source: 'eval factorial<Hash>(79)'
    expr: 
      FuncExpr:
        source: 'factorial<Hash>(79)'
        name: factorial_243
        args:
        - 
          ValueExpr:
              value: '79'
              trits: '1-0010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'YC9999999999999999999999999999999999999999999999999999999999999999999999999999999'
  # test true = hasDivisor<Int>(8, 1, 3)
  -
    source: 'test true = hasDivisor<Int>(8, 1, 3)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'hasDivisor<Int>(8, 1, 3)'
        name: hasDivisor_27
        args:
        - 
          ValueExpr:
              value: '8'
              trits: '-01000000000000000000000000'
              trytes: 'H99999999'
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
        - 
          ValueExpr:
              value: '3'
              trits: '010000000000000000000000000'
              trytes: 'C99999999'
  # test false = hasDivisor<Int>(8, 3, 4)
  -
    source: 'test false = hasDivisor<Int>(8, 3, 4)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'hasDivisor<Int>(8, 3, 4)'
        name: hasDivisor_27
        args:
        - 
          ValueExpr:
              value: '8'
              trits: '-01000000000000000000000000'
              trytes: 'H99999999'
        - 
          ValueExpr:
              value: '3'
              trits: '010000000000000000000000000'
              trytes: 'C99999999'
        - 
          ValueExpr:
              value: '4'
              trits: '110000000000000000000000000'
              trytes: 'D99999999'
  # test true = isPrime<Int>(2)
  -
    source: 'test true = isPrime<Int>(2)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(2)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '2'
              trits: '-10000000000000000000000000'
              trytes: 'B99999999'
  # test true = isPrime<Int>(3)
  -
    source: 'test true = isPrime<Int>(3)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(3)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '3'
              trits: '010000000000000000000000000'
              trytes: 'C99999999'
  # test false = isPrime<Int>(4)
  -
    source: 'test false = isPrime<Int>(4)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(4)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '4'
              trits: '110000000000000000000000000'
              trytes: 'D99999999'
  # test true = isPrime<Int>(5)
  -
    source: 'test true = isPrime<Int>(5)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(5)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '5'
              trits: '--1000000000000000000000000'
              trytes: 'E99999999'
  # test false = isPrime<Int>(6)
  -
    source: 'test false = isPrime<Int>(6)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(6)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '6'
              trits: '0-1000000000000000000000000'
              trytes: 'F99999999'
  # test true = isPrime<Int>(7)
  -
    source: 'test true = isPrime<Int>(7)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(7)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '7'
              trits: '1-1000000000000000000000000'
              trytes: 'G99999999'
  # test false = isPrime<Int>(8)
  -
    source: 'test false = isPrime<Int>(8)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(8)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '8'
              trits: '-01000000000000000000000000'
              trytes: 'H99999999'
  # test false = isPrime<Int>(9)
  -
    source: 'test false = isPrime<Int>(9)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(9)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '9'
              trits: '001000000000000000000000000'
              trytes: 'I99999999'
  # test false = isPrime<Int>(10)
  -
    source: 'test false = isPrime<Int>(10)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(10)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '10'
              trits: '101000000000000000000000000'
              trytes: 'J99999999'
  # test true = isPrime<Int>(11)
  -
    source: 'test true = isPrime<Int>(11)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(11)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '11'
              trits: '-11000000000000000000000000'
              trytes: 'K99999999'
  # test false = isPrime<Int>(12)
  -
    source: 'test false = isPrime<Int>(12)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(12)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '12'
              trits: '011000000000000000000000000'
              trytes: 'L99999999'
  # test true = isPrime<Int>(13)
  -
    source: 'test true = isPrime<Int>(13)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(13)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '13'
              trits: '111000000000000000000000000'
              trytes: 'M99999999'
  # test false = isPrime<Int>(14)
  -
    source: 'test false = isPrime<Int>(14)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(14)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '14'
              trits: '---100000000000000000000000'
              trytes: 'NA9999999'
  # test false = isPrime<Int>(15)
  -
    source: 'test false = isPrime<Int>(15)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(15)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '15'
              trits: '0--100000000000000000000000'
              trytes: 'OA9999999'
  # test false = isPrime<Int>(16)
  -
    source: 'test false = isPrime<Int>(16)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(16)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '16'
              trits: '1--100000000000000000000000'
              trytes: 'PA9999999'
  # test true = isPrime<Int>(17)
  -
    source: 'test true = isPrime<Int>(17)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(17)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '17'
              trits: '-0-100000000000000000000000'
              trytes: 'QA9999999'
  # test false = isPrime<Int>(18)
  -
    source: 'test false = isPrime<Int>(18)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(18)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '18'
              trits: '00-100000000000000000000000'
              trytes: 'RA9999999'
  # test true = isPrime<Int>(19)
  -
    source: 'test true = isPrime<Int>(19)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '1'
          trytes: 'A'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(19)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '19'
              trits: '10-100000000000000000000000'
              trytes: 'SA9999999'
  # test false = isPrime<Int>(20)
  -
    source: 'test false = isPrime<Int>(20)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Int>(20)'
        name: isPrime_27
        args:
        - 
          ValueExpr:
              value: '20'
              trits: '-1-100000000000000000000000'
              trytes: 'TA9999999'
  # test false = isPrime<Huge>(1000000)
  -
    source: 'test false = isPrime<Huge>(1000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Huge>(1000000)'
        name: isPrime_81
        args:
        - 
          ValueExpr:
              value: '1000000'
              trits: '100-1-11-0-0-10000000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'ATVXB9999999999999999999999'
  # test false = isPrime<Huge>(10000000)
  -
    source: 'test false = isPrime<Huge>(10000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Huge>(10000000)'
        name: isPrime_81
        args:
        - 
          ValueExpr:
              value: '10000000'
              trits: '101-1110011-10-100000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'JKAVSA999999999999999999999'
  # test false = isPrime<Huge>(100000000)
  -
    source: 'test false = isPrime<Huge>(100000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Huge>(100000000)'
        name: isPrime_81
        args:
        - 
          ValueExpr:
              value: '100000000'
              trits: '10-0-1-----1-001-1000000000000000000000000000000000000000000000000000000000000000'
              trytes: 'SFNEZG999999999999999999999'
  # test false = isPrime<Huge>(1000000000)
  -
    source: 'test false = isPrime<Huge>(1000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Huge>(1000000000)'
        name: isPrime_81
        args:
        - 
          ValueExpr:
              value: '1000000000'
              trits: '1000101-100-10-1--010000000000000000000000000000000000000000000000000000000000000'
              trytes: 'ACGRSPC99999999999999999999'
  # test false = isPrime<Huge>(10000000000)
  -
    source: 'test false = isPrime<Huge>(10000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Huge>(10000000000)'
        name: isPrime_81
        args:
        - 
          ValueExpr:
              value: '10000000000'
              trits: '101010-0-01-1-011--00100000000000000000000000000000000000000000000000000000000000'
              trytes: 'JCQUYVZA9999999999999999999'
  # test false = isPrime<Huge>(100000000000)
  -
    source: 'test false = isPrime<Huge>(100000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '0'
          trytes: '9'
    expr: 
      FuncExpr:
        source: 'isPrime<Huge>(100000000000)'
        name: isPrime_81
        args:
        - 
          ValueExpr:
              value: '100000000000'
              trits: '10-1-1001-0---10100--101000000000000000000000000000000000000000000000000000000000'
              trytes: 'SGIQECOJ9999999999999999999'
  # eval primesList<Int>(1, 100)
  -
    source: 'eval primesList<Int>(1, 100)'
    expr: 
      FuncExpr:
        source: 'primesList<Int>(1, 100)'
        name: primesList_27
        args:
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
        - 
          ValueExpr:
              value: '100'
              trits: '10-110000000000000000000000'
              trytes: 'SD9999999'
  # test 0 = sqrtFloor<Int>(0)
  -
    source: 'test 0 = sqrtFloor<Int>(0)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '0'
          trits: '000000000000000000000000000'
          trytes: '999999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(0)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '0'
              trits: '000000000000000000000000000'
              trytes: '999999999'
  # test 1 = sqrtFloor<Int>(1)
  -
    source: 'test 1 = sqrtFloor<Int>(1)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000000000000000000000'
          trytes: 'A99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(1)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
  # test 1 = sqrtFloor<Int>(2)
  -
    source: 'test 1 = sqrtFloor<Int>(2)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000000000000000000000'
          trytes: 'A99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(2)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '2'
              trits: '-10000000000000000000000000'
              trytes: 'B99999999'
  # test 1 = sqrtFloor<Int>(3)
  -
    source: 'test 1 = sqrtFloor<Int>(3)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000000000000000000000'
          trytes: 'A99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(3)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '3'
              trits: '010000000000000000000000000'
              trytes: 'C99999999'
  # test 2 = sqrtFloor<Int>(4)
  -
    source: 'test 2 = sqrtFloor<Int>(4)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000000000000000000000'
          trytes: 'B99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(4)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '4'
              trits: '110000000000000000000000000'
              trytes: 'D99999999'
  # test 2 = sqrtFloor<Int>(5)
  -
    source: 'test 2 = sqrtFloor<Int>(5)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000000000000000000000'
          trytes: 'B99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(5)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '5'
              trits: '--1000000000000000000000000'
              trytes: 'E99999999'
  # test 2 = sqrtFloor<Int>(6)
  -
    source: 'test 2 = sqrtFloor<Int>(6)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000000000000000000000'
          trytes: 'B99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(6)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '6'
              trits: '0-1000000000000000000000000'
              trytes: 'F99999999'
  # test 2 = sqrtFloor<Int>(7)
  -
    source: 'test 2 = sqrtFloor<Int>(7)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000000000000000000000'
          trytes: 'B99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(7)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '7'
              trits: '1-1000000000000000000000000'
              trytes: 'G99999999'
  # test 2 = sqrtFloor<Int>(8)
  -
    source: 'test 2 = sqrtFloor<Int>(8)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '2'
          trits: '-10000000000000000000000000'
          trytes: 'B99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(8)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '8'
              trits: '-01000000000000000000000000'
              trytes: 'H99999999'
  # test 3 = sqrtFloor<Int>(9)
  -
    source: 'test 3 = sqrtFloor<Int>(9)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '3'
          trits: '010000000000000000000000000'
          trytes: 'C99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(9)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '9'
              trits: '001000000000000000000000000'
              trytes: 'I99999999'
  # test 4 = sqrtFloor<Int>(16)
  -
    source: 'test 4 = sqrtFloor<Int>(16)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '4'
          trits: '110000000000000000000000000'
          trytes: 'D99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(16)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '16'
              trits: '1--100000000000000000000000'
              trytes: 'PA9999999'
  # test 4 = sqrtFloor<Int>(17)
  -
    source: 'test 4 = sqrtFloor<Int>(17)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '4'
          trits: '110000000000000000000000000'
          trytes: 'D99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(17)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '17'
              trits: '-0-100000000000000000000000'
              trytes: 'QA9999999'
  # test 4 = sqrtFloor<Int>(23)
  -
    source: 'test 4 = sqrtFloor<Int>(23)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '4'
          trits: '110000000000000000000000000'
          trytes: 'D99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(23)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '23'
              trits: '--0100000000000000000000000'
              trytes: 'WA9999999'
  # test 5 = sqrtFloor<Int>(25)
  -
    source: 'test 5 = sqrtFloor<Int>(25)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '5'
          trits: '--1000000000000000000000000'
          trytes: 'E99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(25)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '25'
              trits: '1-0100000000000000000000000'
              trytes: 'YA9999999'
  # test 5 = sqrtFloor<Int>(26)
  -
    source: 'test 5 = sqrtFloor<Int>(26)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '5'
          trits: '--1000000000000000000000000'
          trytes: 'E99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(26)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '26'
              trits: '-00100000000000000000000000'
              trytes: 'ZA9999999'
  # test 13 = sqrtFloor<Int>(169)
  -
    source: 'test 13 = sqrtFloor<Int>(169)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '13'
          trits: '111000000000000000000000000'
          trytes: 'M99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(169)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '169'
              trits: '1-10-1000000000000000000000'
              trytes: 'GF9999999'
  # test 314159 = sqrtFloor<Huge>(add<Huge>(mul<Huge>(314159, 314159), 271828))
  -
    source: 'test 314159 = sqrtFloor<Huge>(add<Huge>(mul<Huge>(314159, 314159), 271828))'
    isFloat: false
    expected: 
      ValueExpr:
          value: '314159'
          trits: '----00-001--100000000000000000000000000000000000000000000000000000000000000000000'
          trytes: 'NZZPA9999999999999999999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Huge>(add<Huge>(mul<Huge>(314159, 314159), 271828))'
        name: sqrtFloor_81
        args:
        - 
          FuncExpr:
            source: 'add<Huge>(mul<Huge>(314159, 314159), 271828)'
            name: add_81
            args:
            - 
              FuncExpr:
                source: 'mul<Huge>(314159, 314159)'
                name: mul_81
                args:
                - 
                  ValueExpr:
                      value: '314159'
                      trits: '----00-001--100000000000000000000000000000000000000000000000000000000000000000000'
                      trytes: 'NZZPA9999999999999999999999'
                - 
                  ValueExpr:
                      value: '314159'
                      trits: '----00-001--100000000000000000000000000000000000000000000000000000000000000000000'
                      trytes: 'NZZPA9999999999999999999999'
            - 
              ValueExpr:
                  value: '271828'
                  trits: '10-0-011----100000000000000000000000000000000000000000000000000000000000000000000'
                  trytes: 'SXVNA9999999999999999999999'
  # test 1 = sqrtFloor<Int>(1)
  -
    source: 'test 1 = sqrtFloor<Int>(1)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1'
          trits: '100000000000000000000000000'
          trytes: 'A99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(1)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '1'
              trits: '100000000000000000000000000'
              trytes: 'A99999999'
  # test 3 = sqrtFloor<Int>(10)
  -
    source: 'test 3 = sqrtFloor<Int>(10)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '3'
          trits: '010000000000000000000000000'
          trytes: 'C99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(10)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '10'
              trits: '101000000000000000000000000'
              trytes: 'J99999999'
  # test 10 = sqrtFloor<Int>(100)
  -
    source: 'test 10 = sqrtFloor<Int>(100)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '10'
          trits: '101000000000000000000000000'
          trytes: 'J99999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(100)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '100'
              trits: '10-110000000000000000000000'
              trytes: 'SD9999999'
  # test 31 = sqrtFloor<Int>(1000)
  -
    source: 'test 31 = sqrtFloor<Int>(1000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '31'
          trits: '110100000000000000000000000'
          trytes: 'DA9999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(1000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '1000'
              trits: '100101100000000000000000000'
              trytes: 'AJA999999'
  # test 100 = sqrtFloor<Int>(10000)
  -
    source: 'test 100 = sqrtFloor<Int>(10000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '100'
          trits: '10-110000000000000000000000'
          trytes: 'SD9999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(10000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '10000'
              trits: '10110----100000000000000000'
              trytes: 'JSNA99999'
  # test 316 = sqrtFloor<Int>(100000)
  -
    source: 'test 316 = sqrtFloor<Int>(100000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '316'
          trits: '10-011000000000000000000000'
          trytes: 'SL9999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(100000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '100000'
              trits: '10---1-10--1000000000000000'
              trytes: 'SEBE99999'
  # test 1000 = sqrtFloor<Int>(1000000)
  -
    source: 'test 1000 = sqrtFloor<Int>(1000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1000'
          trits: '100101100000000000000000000'
          trytes: 'AJA999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(1000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '1000000'
              trits: '100-1-11-0-0-10000000000000'
              trytes: 'ATVXB9999'
  # test 3162 = sqrtFloor<Int>(10000000)
  -
    source: 'test 3162 = sqrtFloor<Int>(10000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '3162'
          trits: '010001110000000000000000000'
          trytes: 'CID999999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(10000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '10000000'
              trits: '101-1110011-10-100000000000'
              trytes: 'JKAVSA999'
  # test 10000 = sqrtFloor<Int>(100000000)
  -
    source: 'test 10000 = sqrtFloor<Int>(100000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '10000'
          trits: '10110----100000000000000000'
          trytes: 'JSNA99999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(100000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '100000000'
              trits: '10-0-1-----1-001-1000000000'
              trytes: 'SFNEZG999'
  # test 31622 = sqrtFloor<Int>(1000000000)
  -
    source: 'test 31622 = sqrtFloor<Int>(1000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '31622'
          trits: '--11011---10000000000000000'
          trytes: 'EJPB99999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(1000000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '1000000000'
              trits: '1000101-100-10-1--010000000'
              trytes: 'ACGRSPC99'
  # test 100000 = sqrtFloor<Int>(10000000000)
  -
    source: 'test 100000 = sqrtFloor<Int>(10000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '100000'
          trits: '10---1-10--1000000000000000'
          trytes: 'SEBE99999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(10000000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '10000000000'
              trits: '101010-0-01-1-011--00100000'
              trytes: 'JCQUYVZA9'
  # test 316227 = sqrtFloor<Int>(100000000000)
  -
    source: 'test 316227 = sqrtFloor<Int>(100000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '316227'
          trits: '01001--101--100000000000000'
          trytes: 'CUBPA9999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(100000000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '100000000000'
              trits: '10-1-1001-0---10100--101000'
              trytes: 'SGIQECOJ9'
  # test 1000000 = sqrtFloor<Int>(1000000000000)
  -
    source: 'test 1000000 = sqrtFloor<Int>(1000000000000)'
    isFloat: false
    expected: 
      ValueExpr:
          value: '1000000'
          trits: '100-1-11-0-0-10000000000000'
          trytes: 'ATVXB9999'
    expr: 
      FuncExpr:
        source: 'sqrtFloor<Int>(1000000000000)'
        name: sqrtFloor_27
        args:
        - 
          ValueExpr:
              value: '1000000000000'
              trits: '100111-11-1110---11--0--110'
              trytes: 'AMKKSEPOD'
  # eval threeXplusOne<Int>(27)
  -
    source: 'eval threeXplusOne<Int>(27)'
    expr: 
      FuncExpr:
        source: 'threeXplusOne<Int>(27)'
        name: threeXplusOne_27
        args:
        - 
          ValueExpr:
              value: '27'
              trits: '000100000000000000000000000'
              trytes: '9A9999999'
  # eval threeXplusOne<Int>(26171)
  -
    source: 'eval threeXplusOne<Int>(26171)'
    expr: 
      FuncExpr:
        source: 'threeXplusOne<Int>(26171)'
        name: threeXplusOne_27
        args:
        - 
          ValueExpr:
              value: '26171'
              trits: '-010-0001100000000000000000'
              trytes: 'HXIA99999'
